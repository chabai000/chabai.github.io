<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java八股文</title>
      <link href="/2024/03/21/Java%E5%85%AB%E8%82%A1%E6%96%87/"/>
      <url>/2024/03/21/Java%E5%85%AB%E8%82%A1%E6%96%87/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Java的特点"><a href="#1-Java的特点" class="headerlink" title="1.Java的特点"></a>1.Java的特点</h2><p><strong>Java是一门面向对象的编程语言</strong>。面向对象和面向过程的区别参考下一个问题。</p><p><strong>Java具有平台独立性和移植性</strong>。</p><ul><li>Java有一句口号：<code>Write once, run anywhere</code>，一次编写、到处运行。这也是Java的魅力所在。而实现这种特性的正是Java虚拟机JVM。已编译的Java程序可以在任何带有JVM的平台上运行。你可以在windows平台编写代码，然后拿到linux上运行。只要你在编写完代码后，将代码编译成.class文件，再把class文件打成Java包，这个jar包就可以在不同的平台上运行了。</li></ul><p><strong>Java具有稳健性</strong>。</p><ul><li>Java是一个强类型语言，它允许扩展编译时检查潜在类型不匹配问题的功能。Java要求显式的方法声明，它不支持C风格的隐式声明。这些严格的要求保证编译程序能捕捉调用错误，这就导致更可靠的程序。</li><li>异常处理是Java中使得程序更稳健的另一个特征。异常是某种类似于错误的异常条件出现的信号。使用<code>try/catch/finally</code>语句，程序员可以找到出错的处理代码，这就简化了出错处理和恢复的任务。</li></ul><h2 id="2-Java是如何实现跨平台的？"><a href="#2-Java是如何实现跨平台的？" class="headerlink" title="2.Java是如何实现跨平台的？"></a>2.Java是如何实现跨平台的？</h2><p>Java是通过JVM（Java虚拟机）实现跨平台的。</p><p>JVM可以理解成一个软件，不同的平台有不同的版本。我们编写的Java代码，编译后会生成.class 文件（字节码文件）。Java虚拟机就是负责将字节码文件翻译成特定平台下的机器码，通过JVM翻译成机器码之后才能运行。不同平台下编译生成的字节码是一样的，但是由JVM翻译成的机器码却不一样。</p><p>只要在不同平台上安装对应的JVM，就可以运行字节码文件，运行我们编写的Java程序。</p><p>因此，运行Java程序必须有JVM的支持，因为编译的结果不是机器码，必须要经过JVM的翻译才能执行。</p><h2 id="3-Java-与-C-的区别"><a href="#3-Java-与-C-的区别" class="headerlink" title="3.Java 与 C++ 的区别"></a>3.Java 与 C++ 的区别</h2><ul><li>Java 是纯粹的面向对象语言，所有的对象都继承自 java.lang.Object，C++ 兼容 C ，不但支持面向对象也支持面向过程。</li><li>Java 通过虚拟机从而实现跨平台特性， C++ 依赖于特定的平台。</li><li>Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。</li><li>Java 支持自动垃圾回收，而 C++ 需要手动回收。</li><li>Java 不支持多重继承，只能通过实现多个接口来达到相同目的，而 C++ 支持多重继承。</li></ul><h2 id="4-JDK-JRE-JVM三者的关系"><a href="#4-JDK-JRE-JVM三者的关系" class="headerlink" title="4.JDK&#x2F;JRE&#x2F;JVM三者的关系"></a>4.JDK&#x2F;JRE&#x2F;JVM三者的关系</h2><p><strong>JVM</strong></p><p>英文名称（Java Virtual Machine），就是我们耳熟能详的 Java 虚拟机。Java 能够跨平台运行的核心在于 JVM 。</p><p><img src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/20220402230447.png" alt="img"></p><p>所有的java程序会首先被编译为.class的类文件，这种类文件可以在虚拟机上执行。也就是说class文件并不直接与机器的操作系统交互，而是经过虚拟机间接与操作系统交互，由虚拟机将程序解释给本地系统执行。</p><p>针对不同的系统有不同的 jvm 实现，有 Linux 版本的 jvm 实现，也有Windows 版本的 jvm 实现，但是同一段代码在编译后的字节码是一样的。这就是Java能够跨平台，实现一次编写，多处运行的原因所在。</p><p><strong>JRE</strong></p><p>英文名称（Java Runtime Environment），就是Java 运行时环境。我们编写的Java程序必须要在JRE才能运行。它主要包含两个部分，JVM 和 Java 核心类库。</p><p><img src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/20220401234008.png" alt="img"></p><p>JRE是Java的运行环境，并不是一个开发环境，所以没有包含任何开发工具，如编译器和调试器等。</p><p>如果你只是想运行Java程序，而不是开发Java程序的话，那么你只需要安装JRE即可。</p><p><strong>JDK</strong></p><p>英文名称（Java Development Kit），就是 Java 开发工具包</p><p>学过Java的同学，都应该安装过JDK。当我们安装完JDK之后，目录结构是这样的</p><p><img src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/20220404120509.png" alt="img"></p><p>可以看到，JDK目录下有个JRE，也就是JDK中已经集成了 JRE，不用单独安装JRE。</p><p>另外，JDK中还有一些好用的工具，如jinfo，jps，jstack等。</p><p><img src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/20220404120507.png" alt="img"></p><p>最后，总结一下JDK&#x2F;JRE&#x2F;JVM，他们三者的关系</p><p><strong>JRE &#x3D; JVM + Java 核心类库</strong></p><p><strong>JDK &#x3D; JRE + Java工具 + 编译器 + 调试器</strong></p><p><img src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/20220402230613.png" alt="img"></p><h2 id="5-Java程序是编译执行还是解释执行？"><a href="#5-Java程序是编译执行还是解释执行？" class="headerlink" title="5.Java程序是编译执行还是解释执行？"></a>5.Java程序是编译执行还是解释执行？</h2><p>先看看什么是编译型语言和解释型语言。</p><p><strong>编译型语言</strong></p><p>在程序运行之前，通过编译器将源程序编译成机器码可运行的二进制，以后执行这个程序时，就不用再进行编译了。</p><p>优点：编译器一般会有预编译的过程对代码进行优化。因为编译只做一次，运行时不需要编译，所以编译型语言的程序执行效率高，可以脱离语言环境独立运行。</p><p>缺点：编译之后如果需要修改就需要整个模块重新编译。编译的时候根据对应的运行环境生成机器码，不同的操作系统之间移植就会有问题，需要根据运行的操作系统环境编译不同的可执行文件。</p><p><strong>总结</strong>：执行速度快、效率高；依靠编译器、跨平台性差些。</p><p><strong>代表语言</strong>：C、C++、Pascal、Object-C以及Swift。</p><p><strong>解释型语言</strong></p><p>定义：解释型语言的源代码不是直接翻译成机器码，而是先翻译成中间代码，再由解释器对中间代码进行解释运行。在运行的时候才将源程序翻译成机器码，翻译一句，然后执行一句，直至结束。</p><p>优点：</p><ol><li>有良好的平台兼容性，在任何环境中都可以运行，前提是安装了解释器（如虚拟机）。</li><li>灵活，修改代码的时候直接修改就可以，可以快速部署，不用停机维护。</li></ol><p>缺点：每次运行的时候都要解释一遍，性能上不如编译型语言。</p><p>总结：解释型语言执行速度慢、效率低；依靠解释器、跨平台性好。</p><p>代表语言：JavaScript、Python、Erlang、PHP、Perl、Ruby。</p><p>对于Java这种语言，它的<strong>源代码</strong>会先通过javac编译成<strong>字节码</strong>，再通过jvm将字节码转换成<strong>机器码</strong>执行，即解释运行 和编译运行配合使用，所以可以称为混合型或者半编译型。</p><h2 id="6-面向对象和面向过程的区别？"><a href="#6-面向对象和面向过程的区别？" class="headerlink" title="6.面向对象和面向过程的区别？"></a>6.面向对象和面向过程的区别？</h2><p>面向对象和面向过程是一种软件开发思想。</p><ul><li>面向过程就是分析出解决问题所需要的步骤，然后用函数按这些步骤实现，使用的时候依次调用就可以了。</li><li>面向对象是把构成问题事务分解成各个对象，分别设计这些对象，然后将他们组装成有完整功能的系统。面向过程只用函数实现，面向对象是用类实现各个功能模块。</li></ul><p>以五子棋为例，面向过程的设计思路就是首先分析问题的步骤：</p><p>1、开始游戏，2、黑子先走，3、绘制画面，4、判断输赢，5、轮到白子，6、绘制画面，7、判断输赢，8、返回步骤2，9、输出最后结果。<br>把上面每个步骤用分别的函数来实现，问题就解决了。</p><p>而面向对象的设计则是从另外的思路来解决问题。整个五子棋可以分为：</p><ol><li>黑白双方</li><li>棋盘系统，负责绘制画面</li><li>规则系统，负责判定诸如犯规、输赢等。</li></ol><p>黑白双方负责接受用户的输入，并告知棋盘系统棋子布局发生变化，棋盘系统接收到了棋子的变化的信息就负责在屏幕上面显示出这种变化，同时利用规则系统来对棋局进行判定。</p><h2 id="7-面向对象有哪些特性？"><a href="#7-面向对象有哪些特性？" class="headerlink" title="7.面向对象有哪些特性？"></a>7.面向对象有哪些特性？</h2><p>面向对象四大特性：封装，继承，多态，抽象</p><p>1、封装就是将类的信息隐藏在类内部，不允许外部程序直接访问，而是通过该类的方法实现对隐藏信息的操作和访问。 良好的封装能够减少耦合。</p><p>2、继承是从已有的类中派生出新的类，新的类继承父类的属性和行为，并能扩展新的能力，大大增加程序的重用性和易维护性。在Java中是单继承的，也就是说一个子类只有一个父类。</p><p>3、多态是同一个行为具有多个不同表现形式的能力。在不修改程序代码的情况下改变程序运行时绑定的代码。实现多态的三要素：继承、重写、父类引用指向子类对象。</p><ul><li>静态多态性：通过重载实现，相同的方法有不同的參数列表，可以根据参数的不同，做出不同的处理。</li><li>动态多态性：在子类中重写父类的方法。运行期间判断所引用对象的实际类型，根据其实际类型调用相应的方法。</li></ul><p>4、抽象。把客观事物用代码抽象出来。</p><h2 id="8-面向对象编程的六大原则"><a href="#8-面向对象编程的六大原则" class="headerlink" title="8.面向对象编程的六大原则?"></a>8.面向对象编程的六大原则?</h2><ul><li><strong>对象单一职责</strong>：我们设计创建的对象，必须职责明确，比如商品类，里面相关的属性和方法都必须跟商品相关，不能出现订单等不相关的内容。这里的类可以是模块、类库、程序集，而不单单指类。</li><li><strong>里式替换原则</strong>：子类能够完全替代父类，反之则不行。通常用于实现接口时运用。因为子类能够完全替代基（父）类，那么这样父类就拥有很多子类，在后续的程序扩展中就很容易进行扩展，程序完全不需要进行修改即可进行扩展。比如IA的实现为A，因为项目需求变更，现在需要新的实现，直接在容器注入处更换接口即可.</li><li><strong>迪米特法则</strong>，也叫最小原则，或者说最小耦合。通常在设计程序或开发程序的时候，尽量要高内聚，低耦合。当两个类进行交互的时候，会产生依赖。而迪米特法则就是建议这种依赖越少越好。就像构造函数注入父类对象时一样，当需要依赖某个对象时，并不在意其内部是怎么实现的，而是在容器中注入相应的实现，既符合里式替换原则，又起到了解耦的作用。</li><li>开闭原则：开放扩展，封闭修改。当项目需求发生变更时，要尽可能的不去对原有的代码进行修改，而在原有的基础上进行扩展。</li><li><strong>依赖倒置原则</strong>：高层模块不应该直接依赖于底层模块的具体实现，而应该依赖于底层的抽象。接口和抽象类不应该依赖于实现类，而实现类依赖接口或抽象类。</li><li><strong>接口隔离原则</strong>：一个对象和另外一个对象交互的过程中，依赖的内容最小。也就是说在接口设计的时候，在遵循对象单一职责的情况下，尽量减少接口的内容。</li></ul><p><strong>简洁版</strong>：</p><ul><li>单一职责：对象设计要求独立，不能设计万能对象。</li><li>开闭原则：对象修改最小化。</li><li>里式替换：程序扩展中抽象被具体可以替换（接口、父类、可以被实现类对象、子类替换对象）</li><li>迪米特：高内聚，低耦合。尽量不要依赖细节。</li><li>依赖倒置：面向抽象编程。也就是参数传递，或者返回值，可以使用父类类型或者接口类型。从广义上讲：基于接口编程，提前设计好接口框架。</li><li>接口隔离：接口设计大小要适中。过大导致污染，过小，导致调用麻烦。</li></ul><h2 id="9-数组到底是不是对象？"><a href="#9-数组到底是不是对象？" class="headerlink" title="9.数组到底是不是对象？"></a>9.数组到底是不是对象？</h2><p>先说说对象的概念。对象是根据某个类创建出来的一个实例，表示某类事物中一个具体的个体。</p><p>对象具有各种属性，并且具有一些特定的行为。站在计算机的角度，对象就是内存中的一个内存块，在这个内存块封装了一些数据，也就是类中定义的各个属性。</p><p>所以，对象是用来封装数据的。</p><p>java中的数组具有java中其他对象的一些基本特点。比如封装了一些数据，可以访问属性，也可以调用方法。</p><p>因此，可以说，数组是对象。</p><p>也可以通过代码验证数组是对象的事实。比如以下的代码，输出结果为java.lang.Object。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clz</span> <span class="operator">=</span> <span class="type">int</span>[].class;</span><br><span class="line">System.out.println(clz.getSuperclass().getName());</span><br></pre></td></tr></table></figure><p>由此，可以看出，数组类的父类就是Object类，那么可以推断出数组就是对象。</p><h2 id="10-Java的基本数据类型有哪些？"><a href="#10-Java的基本数据类型有哪些？" class="headerlink" title="10.Java的基本数据类型有哪些？"></a>10.Java的基本数据类型有哪些？</h2><ul><li>byte，8bit</li><li>char，16bit</li><li>short，16bit</li><li>int，32bit</li><li>float，32bit</li><li>long，64bit</li><li>double，64bit</li><li>boolean，只有两个值：true、false，可以使⽤用 1 bit 来存储</li></ul><table><thead><tr><th>简单类型</th><th>boolean</th><th>byte</th><th>char</th><th>short</th><th>Int</th><th>long</th><th>float</th><th>double</th></tr></thead><tbody><tr><td>二进制位数</td><td>1</td><td>8</td><td>16</td><td>16</td><td>32</td><td>64</td><td>32</td><td>64</td></tr><tr><td>包装类</td><td>Boolean</td><td>Byte</td><td>Character</td><td>Short</td><td>Integer</td><td>Long</td><td>Float</td><td>Double</td></tr></tbody></table><p>在Java规范中，没有明确指出boolean的大小。在《Java虚拟机规范》给出了单个boolean占4个字节，和boolean数组1个字节的定义，具体 <strong>还要看虚拟机实现是否按照规范来</strong>，因此boolean占用1个字节或者4个字节都是有可能的。</p><h2 id="11-为什么不能用浮点型表示金额？"><a href="#11-为什么不能用浮点型表示金额？" class="headerlink" title="11.为什么不能用浮点型表示金额？"></a>11.为什么不能用浮点型表示金额？</h2><p>由于计算机中保存的小数其实是十进制的小数的近似值，并不是准确值，所以，千万不要在代码中使用浮点数来表示金额等重要的指标。</p><p>建议使用BigDecimal或者Long来表示金额。</p><h2 id="12-什么是值传递和引用传递？"><a href="#12-什么是值传递和引用传递？" class="headerlink" title="12.什么是值传递和引用传递？"></a>12.什么是值传递和引用传递？</h2><ul><li>值传递是对基本型变量而言的，传递的是该变量的一个副本，改变副本不影响原变量。</li><li>引用传递一般是对于对象型变量而言的，传递的是该对象地址的一个副本，并不是原对象本身，两者指向同一片内存空间。所以对引用对象进行操作会同时改变原对象。</li></ul><p><strong>java中不存在引用传递，只有值传递</strong>。即不存在变量a指向变量b，变量b指向对象的这种情况。</p><h2 id="13-了解Java的包装类型吗？为什么需要包装类？"><a href="#13-了解Java的包装类型吗？为什么需要包装类？" class="headerlink" title="13.了解Java的包装类型吗？为什么需要包装类？"></a>13.了解Java的包装类型吗？为什么需要包装类？</h2><p>Java 是一种面向对象语言，很多地方都需要使用对象而不是基本数据类型。比如，在集合类中，我们是无法将 int 、double 等类型放进去的。因为集合的容器要求元素是 Object 类型。</p><p>为了让基本类型也具有对象的特征，就出现了包装类型。相当于将基本类型包装起来，使得它具有了对象的性质，并且为其添加了属性和方法，丰富了基本类型的操作。</p><h2 id="14-自动装箱和拆箱"><a href="#14-自动装箱和拆箱" class="headerlink" title="14.自动装箱和拆箱"></a>14.自动装箱和拆箱</h2><p>Java中基础数据类型与它们对应的包装类见下表：</p><table><thead><tr><th align="left">原始类型</th><th align="left">包装类型</th></tr></thead><tbody><tr><td align="left">boolean</td><td align="left">Boolean</td></tr><tr><td align="left">byte</td><td align="left">Byte</td></tr><tr><td align="left">char</td><td align="left">Character</td></tr><tr><td align="left">float</td><td align="left">Float</td></tr><tr><td align="left">int</td><td align="left">Integer</td></tr><tr><td align="left">long</td><td align="left">Long</td></tr><tr><td align="left">short</td><td align="left">Short</td></tr><tr><td align="left">double</td><td align="left">Double</td></tr></tbody></table><p>装箱：将基础类型转化为包装类型。</p><p>拆箱：将包装类型转化为基础类型。</p><p>当基础类型与它们的包装类有如下几种情况时，编译器会<strong>自动</strong>帮我们进行装箱或拆箱：</p><ul><li>赋值操作（装箱或拆箱）</li><li>进行加减乘除混合运算 （拆箱）</li><li>进行&gt;,&lt;,&#x3D;&#x3D;比较运算（拆箱）</li><li>调用equals进行比较（装箱）</li><li>ArrayList、HashMap等集合类添加基础类型数据时（装箱）</li></ul><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 装箱 调⽤ Integer.valueOf(1)</span></span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> x; <span class="comment">// 拆箱 调⽤了 X.intValue()</span></span><br></pre></td></tr></table></figure><p>下面看一道常见的面试题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">System.out.println(a == b);</span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">System.out.println(c == d);</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure><p>为什么第三个输出是false？看看 Integer 类的源码就知道啦。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Integer c = 200;</code> 会调用 调⽤<code>Integer.valueOf(200)</code>。而从Integer的valueOf()源码可以看到，这里的实现并不是简单的new Integer，而是用IntegerCache做一个cache。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IntegerCache</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">integerCacheHighPropValue</span> <span class="operator">=</span></span><br><span class="line">            sun.misc.VM.getSavedProperty(<span class="string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> parseInt(integerCacheHighPropValue);</span><br><span class="line">                i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是IntegerCache静态代码块中的一段，默认Integer cache 的下限是-128，上限默认127。当赋值100给Integer时，刚好在这个范围内，所以从cache中取对应的Integer并返回，所以a和b返回的是同一个对象，所以<code>==</code>比较是相等的，当赋值200给Integer时，不在cache 的范围内，所以会new Integer并返回，当然<code>==</code>比较的结果是不相等的。</p><h2 id="15-String-为什么不可变？"><a href="#15-String-为什么不可变？" class="headerlink" title="15.String 为什么不可变？"></a>15.String 为什么不可变？</h2><p>先看看什么是不可变的对象。</p><p>如果一个对象，在它创建完成之后，不能再改变它的状态，那么这个对象就是不可变的。不能改变状态的意思是，不能改变对象内的成员变量，包括基本数据类型的值不能改变，引用类型的变量不能指向其他的对象，引用类型指向的对象的状态也不能改变。</p><p>接着来看Java8 String类的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码可以看出，String对象其实在内部就是一个个字符，存储在这个value数组里面的。</p><p>value数组用final修饰，final 修饰的变量，值不能被修改。因此value不可以指向其他对象。</p><p>String类内部所有的字段都是私有的，也就是被private修饰。而且String没有对外提供修改内部状态的方法，因此value数组不能改变。</p><p>所以，String是不可变的。</p><p>那为什么String要设计成不可变的？</p><p>主要有以下几点原因：</p><ol><li><strong>线程安全</strong>。同一个字符串实例可以被多个线程共享，因为字符串不可变，本身就是线程安全的。</li><li><strong>支持hash映射和缓存</strong>。因为String的hash值经常会使用到，比如作为 Map 的键，不可变的特性使得 hash 值也不会变，不需要重新计算。</li><li><strong>出于安全考虑</strong>。网络地址URL、文件路径path、密码通常情况下都是以String类型保存，假若String不是固定不变的，将会引起各种安全隐患。比如将密码用String的类型保存，那么它将一直留在内存中，直到垃圾收集器把它清除。假如String类不是固定不变的，那么这个密码可能会被改变，导致出现安全隐患。</li><li><strong>字符串常量池优化</strong>。String对象创建之后，会缓存到字符串常量池中，下次需要创建同样的对象时，可以直接返回缓存的引用。</li></ol><p>既然我们的String是不可变的，它内部还有很多substring， replace， replaceAll这些操作的方法。这些方法好像会改变String对象？怎么解释呢？</p><p>其实不是的，我们每次调用replace等方法，其实会在堆内存中创建了一个新的对象。然后其value数组引用指向不同的对象。</p><h2 id="16-为何JDK9要将String的底层实现由char-改成byte"><a href="#16-为何JDK9要将String的底层实现由char-改成byte" class="headerlink" title="16.为何JDK9要将String的底层实现由char[]改成byte[]?"></a>16.为何JDK9要将String的底层实现由char[]改成byte[]?</h2><p>主要是为了<strong>节约String占用的内存</strong>。</p><p>在大部分Java程序的堆内存中，String占用的空间最大，并且绝大多数String只有Latin-1字符，这些Latin-1字符只需要1个字节就够了。</p><p>而在JDK9之前，JVM因为String使用char数组存储，每个char占2个字节，所以即使字符串只需要1字节，它也要按照2字节进行分配，浪费了一半的内存空间。</p><p>到了JDK9之后，对于每个字符串，会先判断它是不是只有Latin-1字符，如果是，就按照1字节的规格进行分配内存，如果不是，就按照2字节的规格进行分配，这样便提高了内存使用率，同时GC次数也会减少，提升效率。</p><p>不过Latin-1编码集支持的字符有限，比如不支持中文字符，因此对于中文字符串，用的是UTF16编码（两个字节），所以用byte[]和char[]实现没什么区别。</p><h2 id="17-String-StringBuffer-和-StringBuilder区别"><a href="#17-String-StringBuffer-和-StringBuilder区别" class="headerlink" title="17.String, StringBuffer 和 StringBuilder区别"></a>17.String, StringBuffer 和 StringBuilder区别</h2><p><strong>1. 可变性</strong></p><ul><li>String 不可变</li><li>StringBuffer 和 StringBuilder 可变</li></ul><p><strong>2. 线程安全</strong></p><ul><li>String 不可变，因此是线程安全的</li><li>StringBuilder 不是线程安全的</li><li>StringBuffer 是线程安全的，内部使用 synchronized 进行同步</li></ul><h2 id="18-什么是StringJoiner？"><a href="#18-什么是StringJoiner？" class="headerlink" title="18.什么是StringJoiner？"></a>18.什么是StringJoiner？</h2><p>StringJoiner是 Java 8 新增的一个 API，它基于 StringBuilder 实现，用于实现对字符串之间通过分隔符拼接的场景。</p><p>StringJoiner 有两个构造方法，第一个构造要求依次传入分隔符、前缀和后缀。第二个构造则只要求传入分隔符即可（前缀和后缀默认为空字符串）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StringJoiner(CharSequence delimiter, CharSequence prefix, CharSequence suffix)</span><br><span class="line">StringJoiner(CharSequence delimiter)</span><br></pre></td></tr></table></figure><p>有些字符串拼接场景，使用 StringBuffer 或 StringBuilder 则显得比较繁琐。</p><p>比如下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; values = Arrays.asList(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;(&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; values.size(); i++) &#123;</span><br><span class="line">sb.append(values.get(i));</span><br><span class="line"><span class="keyword">if</span> (i != values.size() -<span class="number">1</span>) &#123;</span><br><span class="line">sb.append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sb.append(<span class="string">&quot;)&quot;</span>);</span><br></pre></td></tr></table></figure><p>而通过StringJoiner来实现拼接List的各个元素，代码看起来更加简洁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; values = Arrays.asList(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line"><span class="type">StringJoiner</span> <span class="variable">sj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringJoiner</span>(<span class="string">&quot;,&quot;</span>, <span class="string">&quot;(&quot;</span>, <span class="string">&quot;)&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Integer value : values) &#123;</span><br><span class="line">sj.add(value.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，像平时经常使用的Collectors.joining(“,”)，底层就是通过StringJoiner实现的。</p><p>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Collector&lt;CharSequence, ?, String&gt; joining(</span><br><span class="line">    CharSequence delimiter,CharSequence prefix,CharSequence suffix) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CollectorImpl</span>&lt;&gt;(</span><br><span class="line">            () -&gt; <span class="keyword">new</span> <span class="title class_">StringJoiner</span>(delimiter, prefix, suffix),</span><br><span class="line">            StringJoiner::add, StringJoiner::merge,</span><br><span class="line">            StringJoiner::toString, CH_NOID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="19-String-类的常用方法有哪些？"><a href="#19-String-类的常用方法有哪些？" class="headerlink" title="19.String 类的常用方法有哪些？"></a>19.String 类的常用方法有哪些？</h2><ul><li>indexOf()：返回指定字符的索引。</li><li>charAt()：返回指定索引处的字符。</li><li>replace()：字符串替换。</li><li>trim()：去除字符串两端空白。</li><li>split()：分割字符串，返回一个分割后的字符串数组。</li><li>getBytes()：返回字符串的 byte 类型数组。</li><li>length()：返回字符串长度。</li><li>toLowerCase()：将字符串转成小写字母。</li><li>toUpperCase()：将字符串转成大写字符。</li><li>substring()：截取字符串。</li><li>equals()：字符串比较。</li></ul><h2 id="20-new-String-“dabin”-会创建几个对象？"><a href="#20-new-String-“dabin”-会创建几个对象？" class="headerlink" title="20.new String(“dabin”)会创建几个对象？"></a>20.new String(“dabin”)会创建几个对象？</h2><p>使用这种方式会创建两个字符串对象（前提是字符串常量池中没有 “dabin” 这个字符串对象）。</p><ul><li>“dabin” 属于字符串字面量，因此编译时期会在字符串常量池中创建一个字符串对象，指向这个 “dabin” 字符串字面量；</li><li>使用 new 的方式会在堆中创建一个字符串对象。</li></ul><h2 id="21-什么是字符串常量池？"><a href="#21-什么是字符串常量池？" class="headerlink" title="21.什么是字符串常量池？"></a>21.什么是字符串常量池？</h2><p>字符串常量池（String Pool）保存着所有字符串字面量，这些字面量在编译时期就确定。字符串常量池位于堆内存中，专门用来存储字符串常量。在创建字符串时，JVM首先会检查字符串常量池，如果该字符串已经存在池中，则返回其引用，如果不存在，则创建此字符串并放入池中，并返回其引用。</p><h2 id="22-String最大长度是多少？"><a href="#22-String最大长度是多少？" class="headerlink" title="22.String最大长度是多少？"></a>22.String最大长度是多少？</h2><p>String类提供了一个length方法，返回值为int类型，而int的取值上限为2^31 -1。</p><p>所以理论上String的最大长度为2^31 -1。</p><p><strong>达到这个长度的话需要多大的内存吗</strong>？</p><p>String内部是使用一个char数组来维护字符序列的，一个char占用两个字节。如果说String最大长度是2^31 -1的话，那么最大的字符串占用内存空间约等于4GB。</p><p>也就是说，我们需要有大于4GB的JVM运行内存才行。</p><p><strong>那String一般都存储在JVM的哪块区域呢</strong>？</p><p>字符串在JVM中的存储分两种情况，一种是String对象，存储在JVM的堆栈中。一种是字符串常量，存储在常量池里面。</p><p><strong>什么情况下字符串会存储在常量池呢</strong>？</p><p>当通过字面量进行字符串声明时，比如String s &#x3D; “茶白”;，这个字符串在编译之后会以常量的形式进入到常量池。</p><p><strong>那常量池中的字符串最大长度是2^31-1吗</strong>？</p><p>不是的，常量池对String的长度是有另外限制的。。Java中的UTF-8编码的Unicode字符串在常量池中以CONSTANT_Utf8类型表示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_Utf8_info &#123;</span><br><span class="line">    u1 tag;</span><br><span class="line">    u2 length;</span><br><span class="line">    u1 bytes[length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>length在这里就是代表字符串的长度，length的类型是u2，u2是无符号的16位整数，也就是说最大长度可以做到2^16-1 即 65535。</p><p>不过javac编译器做了限制，需要length &lt; 65535。所以字符串常量在常量池中的最大长度是65535 - 1 &#x3D; 65534。</p><p>最后总结一下：</p><p>String在不同的状态下，具有不同的长度限制。</p><ul><li>字符串常量长度不能超过65534</li><li>堆内字符串的长度不超过2^31-1</li></ul><h2 id="23-Object常用方法有哪些？"><a href="#23-Object常用方法有哪些？" class="headerlink" title="23.Object常用方法有哪些？"></a>23.Object常用方法有哪些？</h2><p>Java面试经常会出现的一道题目，Object的常用方法。下面给大家整理一下。</p><p>Object常用方法有：<code>toString()</code>、<code>equals()</code>、<code>hashCode()</code>、<code>clone()</code>等。</p><p><strong>toString</strong></p><p>默认输出对象地址。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(<span class="type">int</span> age, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">18</span>, <span class="string">&quot;茶白&quot;</span>).toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//output</span></span><br><span class="line">    <span class="comment">//me.tyson.java.core.Person@4554617c</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以重写toString方法，按照重写逻辑输出对象值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(<span class="type">int</span> age, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name + <span class="string">&quot;:&quot;</span> + age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">18</span>, <span class="string">&quot;茶白&quot;</span>).toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//output</span></span><br><span class="line">    <span class="comment">//茶白:18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>equals</strong></p><p>默认比较两个引用变量是否指向同一个对象（内存地址）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(<span class="type">int</span> age, String name)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.age = age;</span><br><span class="line">       <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;茶白&quot;</span>;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">18</span>, name);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">18</span>, name);</span><br><span class="line"></span><br><span class="line">        System.out.println(p1.equals(p2));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//output</span></span><br><span class="line">    <span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以重写equals方法，按照age和name是否相等来判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(<span class="type">int</span> age, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">            <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person) o;</span><br><span class="line">            <span class="keyword">return</span> age == p.age &amp;&amp; name.equals(p.name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;茶白&quot;</span>;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">18</span>, name);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">18</span>, name);</span><br><span class="line"></span><br><span class="line">        System.out.println(p1.equals(p2));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//output</span></span><br><span class="line">    <span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>hashCode</strong></p><p>将与对象相关的信息映射成一个哈希值，默认的实现hashCode值是根据内存地址换算出来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">Cat</span>().hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//out</span></span><br><span class="line">    <span class="comment">//1349277854</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>clone</strong></p><p>Java赋值是复制对象引用，如果我们想要得到一个对象的副本，使用赋值操作是无法达到目的的。Object对象有个clone()方法，实现了对</p><p>象中各个属性的复制，但它的可见范围是protected的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException;</span><br></pre></td></tr></table></figure><p>所以实体类使用克隆的前提是：</p><ul><li>实现Cloneable接口，这是一个标记接口，自身没有方法，这应该是一种约定。调用clone方法时，会判断有没有实现Cloneable接口，没有实现Cloneable的话会抛异常CloneNotSupportedException。</li><li>覆盖clone()方法，可见性提升为public。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        c.name = <span class="string">&quot;茶白&quot;</span>;</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cloneCat</span> <span class="operator">=</span> (Cat) c.clone();</span><br><span class="line">        c.name = <span class="string">&quot;茶白&quot;</span>;</span><br><span class="line">        System.out.println(cloneCat.name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//output</span></span><br><span class="line">    <span class="comment">//茶白</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>getClass</strong></p><p>返回此 Object 的运行时类，常用于java反射机制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;茶白&quot;</span>);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clz</span> <span class="operator">=</span> p.getClass();</span><br><span class="line">        System.out.println(clz);</span><br><span class="line">        <span class="comment">//获取类名</span></span><br><span class="line">        System.out.println(clz.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * class com.tyson.basic.Person</span></span><br><span class="line"><span class="comment">     * com.tyson.basic.Person</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>wait</strong></p><p>当前线程调用对象的wait()方法之后，当前线程会释放对象锁，进入等待状态。等待其他线程调用此对象的notify()&#x2F;notifyAll()唤醒或者等待超时时间wait(long timeout)自动唤醒。线程需要获取obj对象锁之后才能调用 obj.wait()。</p><p><strong>notify</strong></p><p>obj.notify()唤醒在此对象上等待的单个线程，选择是任意性的。notifyAll()唤醒在此对象上等待的所有线程。</p><h2 id="24-讲讲深拷贝和浅拷贝？"><a href="#24-讲讲深拷贝和浅拷贝？" class="headerlink" title="24.讲讲深拷贝和浅拷贝？"></a>24.讲讲深拷贝和浅拷贝？</h2><p><strong>浅拷贝</strong>：拷⻉对象和原始对象的引⽤类型引用同⼀个对象。</p><p>以下例子，Cat对象里面有个Person对象，调用clone之后，克隆对象和原对象的Person引用的是同一个对象，这就是浅拷贝。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Person owner;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">18</span>, <span class="string">&quot;茶白&quot;</span>);</span><br><span class="line">        c.owner = p;</span><br><span class="line"></span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cloneCat</span> <span class="operator">=</span> (Cat) c.clone();</span><br><span class="line">        p.setName(<span class="string">&quot;茶白&quot;</span>);</span><br><span class="line">        System.out.println(cloneCat.owner.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//output</span></span><br><span class="line">    <span class="comment">//茶白</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>深拷贝</strong>：拷贝对象和原始对象的引用类型引用不同的对象。</p><p>以下例子，在clone函数中不仅调用了super.clone，而且调用Person对象的clone方法（Person也要实现Cloneable接口并重写clone方法），从而实现了深拷贝。可以看到，拷贝对象的值不会受到原对象的影响。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Person owner;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        c = (Cat) <span class="built_in">super</span>.clone();</span><br><span class="line">        c.owner = (Person) owner.clone();<span class="comment">//拷贝Person对象</span></span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">18</span>, <span class="string">&quot;茶白&quot;</span>);</span><br><span class="line">        c.owner = p;</span><br><span class="line"></span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cloneCat</span> <span class="operator">=</span> (Cat) c.clone();</span><br><span class="line">        p.setName(<span class="string">&quot;茶白&quot;</span>);</span><br><span class="line">        System.out.println(cloneCat.owner.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//output</span></span><br><span class="line">    <span class="comment">//茶白</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="25-两个对象的hashCode-相同，则-equals-是否也一定为-true？"><a href="#25-两个对象的hashCode-相同，则-equals-是否也一定为-true？" class="headerlink" title="25.两个对象的hashCode()相同，则 equals()是否也一定为 true？"></a>25.两个对象的hashCode()相同，则 equals()是否也一定为 true？</h2><p>equals与hashcode的关系：</p><ol><li>如果两个对象调用equals比较返回true，那么它们的hashCode值一定要相同；</li><li>如果两个对象的hashCode相同，它们并不一定相同。</li></ol><p>hashcode方法主要是用来<strong>提升对象比较的效率</strong>，先进行hashcode()的比较，如果不相同，那就不必在进行equals的比较，这样就大大减少了equals比较的次数，当比较对象的数量很大的时候能提升效率。</p><h2 id="26-为什么重写-equals-时一定要重写-hashCode？"><a href="#26-为什么重写-equals-时一定要重写-hashCode？" class="headerlink" title="26.为什么重写 equals 时一定要重写 hashCode？"></a>26.为什么重写 equals 时一定要重写 hashCode？</h2><p>之所以重写<code>equals()</code>要重写<code>hashcode()</code>，是为了保证<code>equals()</code>方法返回true的情况下hashcode值也要一致，如果重写了<code>equals()</code>没有重写<code>hashcode()</code>，就会出现两个对象相等但<code>hashcode()</code>不相等的情况。这样，当用其中的一个对象作为键保存到hashMap、hashTable或hashSet中，再以另一个对象作为键值去查找他们的时候，则会查找不到。</p><h2 id="27-Java创建对象有几种方式？"><a href="#27-Java创建对象有几种方式？" class="headerlink" title="27.Java创建对象有几种方式？"></a>27.Java创建对象有几种方式？</h2><p>Java创建对象有以下几种方式：</p><ul><li>用new语句创建对象。</li><li>使用反射，使用Class.newInstance()创建对象。</li><li>调用对象的clone()方法。</li><li>运用反序列化手段，调用java.io.ObjectInputStream对象的readObject()方法。</li></ul><h2 id="28-说说类实例化的顺序"><a href="#28-说说类实例化的顺序" class="headerlink" title="28.说说类实例化的顺序"></a>28.说说类实例化的顺序</h2><p>Java中类实例化顺序：</p><ol><li>静态属性，静态代码块。</li><li>普通属性，普通代码块。</li><li>构造方法。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LifeCycle</span> &#123;</span><br><span class="line">    <span class="comment">// 静态属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">staticField</span> <span class="operator">=</span> getStaticField();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态代码块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(staticField);</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 普通属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">field</span> <span class="operator">=</span> getField();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 普通代码块</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(field);</span><br><span class="line">        System.out.println(<span class="string">&quot;普通代码块初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LifeCycle</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造方法初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getStaticField</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">statiFiled</span> <span class="operator">=</span> <span class="string">&quot;静态属性初始化&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> statiFiled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 普通方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getField</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">filed</span> <span class="operator">=</span> <span class="string">&quot;普通属性初始化&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> filed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argc)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">LifeCycle</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *      静态属性初始化</span></span><br><span class="line"><span class="comment">     *      静态代码块初始化</span></span><br><span class="line"><span class="comment">     *      普通属性初始化</span></span><br><span class="line"><span class="comment">     *      普通代码块初始化</span></span><br><span class="line"><span class="comment">     *      构造方法初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="29-equals和-有什么区别？"><a href="#29-equals和-有什么区别？" class="headerlink" title="29.equals和&#x3D;&#x3D;有什么区别？"></a>29.equals和&#x3D;&#x3D;有什么区别？</h2><ul><li>对于基本数据类型，&#x3D;&#x3D;比较的是他们的值。基本数据类型没有equal方法；</li><li>对于复合数据类型，&#x3D;&#x3D;比较的是它们的存放地址(是否是同一个对象)。<code>equals()</code>默认比较地址值，重写的话按照重写逻辑去比较。</li></ul><h2 id="30-常见的关键字有哪些？"><a href="#30-常见的关键字有哪些？" class="headerlink" title="30.常见的关键字有哪些？"></a>30.常见的关键字有哪些？</h2><p><strong>static</strong></p><p>static可以用来修饰类的成员方法、类的成员变量。</p><p>static变量也称作<strong>静态变量</strong>，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。</p><p>以下例子，age为非静态变量，则p1打印结果是：<code>Name:zhangsan, Age:10</code>；若age使用static修饰，则p1打印结果是：<code>Name:zhangsan, Age:12</code>，因为static变量在内存只有一个副本。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Name:&quot;</span> + name + <span class="string">&quot;, Age:&quot;</span> + age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        p1.name = <span class="string">&quot;zhangsan&quot;</span>;</span><br><span class="line">        p1.age = <span class="number">10</span>;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        p2.name = <span class="string">&quot;lisi&quot;</span>;</span><br><span class="line">        p2.age = <span class="number">12</span>;</span><br><span class="line">        System.out.println(p1);</span><br><span class="line">        System.out.println(p2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**Output</span></span><br><span class="line"><span class="comment">     * Name:zhangsan, Age:10</span></span><br><span class="line"><span class="comment">     * Name:lisi, Age:12</span></span><br><span class="line"><span class="comment">     */</span><span class="comment">//~</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>static方法一般称作<strong>静态方法</strong>。静态方法不依赖于任何对象就可以进行访问，通过类名即可调用静态方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Utils</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world: &quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Utils.print(<span class="string">&quot;茶白&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>静态代码块</strong>只会在类加载的时候执行一次。以下例子，startDate和endDate在类加载的时候进行赋值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>  &#123;</span><br><span class="line">    <span class="keyword">private</span> Date birthDate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Date startDate, endDate;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        startDate = Date.valueOf(<span class="string">&quot;2008&quot;</span>);</span><br><span class="line">        endDate = Date.valueOf(<span class="string">&quot;2021&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(Date birthDate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.birthDate = birthDate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>静态内部类</strong></p><p><strong>在静态方法里</strong>，使用⾮静态内部类依赖于外部类的实例，也就是说需要先创建外部类实例，才能用这个实例去创建非静态内部类。⽽静态内部类不需要。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OuterClass</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">InnerClass</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StaticInnerClass</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 在静态方法里，不能直接使用OuterClass.this去创建InnerClass的实例</span></span><br><span class="line">        <span class="comment">// 需要先创建OuterClass的实例o，然后通过o创建InnerClass的实例</span></span><br><span class="line">        <span class="comment">// InnerClass innerClass = new InnerClass();</span></span><br><span class="line">        <span class="type">OuterClass</span> <span class="variable">outerClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OuterClass</span>();</span><br><span class="line">        <span class="type">InnerClass</span> <span class="variable">innerClass</span> <span class="operator">=</span> outerClass.<span class="keyword">new</span> <span class="title class_">InnerClass</span>();</span><br><span class="line">        <span class="type">StaticInnerClass</span> <span class="variable">staticInnerClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticInnerClass</span>();</span><br><span class="line"></span><br><span class="line">        outerClass.test();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">nonStaticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">InnerClass</span> <span class="variable">innerClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InnerClass</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;nonStaticMethod...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>final</strong></p><ol><li><strong>基本数据</strong>类型用final修饰，则不能修改，是常量；<strong>对象引用</strong>用final修饰，则引用只能指向该对象，不能指向别的对象，但是对象本身可以修改。</li><li>final修饰的方法不能被子类重写</li><li>final修饰的类不能被继承。</li></ol><p><strong>this</strong></p><p><code>this.属性名称</code>指访问类中的成员变量，可以用来区分成员变量和局部变量。如下代码所示，<code>this.name</code>访问类Person当前实例的变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 茶白</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 2021-08-17 00:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>this.方法名称</code>用来访问本类的方法。以下代码中，<code>this.born()</code>调用类 Person 的当前实例的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 茶白</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 2021-08-17 00:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.born();</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">born</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>super</strong></p><p>super 关键字用于在子类中访问父类的变量和方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;茶白&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类:&quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">super</span>.name);</span><br><span class="line">        <span class="built_in">super</span>.getName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        b.getName();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 茶白</span></span><br><span class="line"><span class="comment">     * 父类:茶白</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在子类B中，我们重写了父类的<code>getName()</code>方法，如果在重写的<code>getName()</code>方法中我们要调用父类的相同方法，必须要通过super关键字显式指出。</p><h2 id="31-final-finally-finalize-的区别"><a href="#31-final-finally-finalize-的区别" class="headerlink" title="31.final, finally, finalize 的区别"></a>31.final, finally, finalize 的区别</h2><ul><li>final 用于修饰属性、方法和类, 分别表示属性不能被重新赋值，方法不可被覆盖，类不可被继承。</li><li>finally 是异常处理语句结构的一部分，一般以<code>try-catch-finally</code>出现，<code>finally</code>代码块表示总是被执行。</li><li>finalize 是Object类的一个方法，该方法一般由垃圾回收器来调用，当我们调用<code>System.gc()</code>方法的时候，由垃圾回收器调用<code>finalize()</code>方法，回收垃圾，JVM并不保证此方法总被调用。</li></ul><h2 id="32-final关键字的作用？"><a href="#32-final关键字的作用？" class="headerlink" title="32.final关键字的作用？"></a>32.final关键字的作用？</h2><ul><li>final 修饰的类不能被继承。</li><li>final 修饰的方法不能被重写。</li><li>final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。</li></ul><h2 id="33-方法重载和重写的区别？"><a href="#33-方法重载和重写的区别？" class="headerlink" title="33.方法重载和重写的区别？"></a>33.方法重载和重写的区别？</h2><p><strong>同个类中的多个方法可以有相同的方法名称，但是有不同的参数列表，这就称为方法重载</strong>。参数列表又叫参数签名，包括参数的类型、参数的个数、参数的顺序，只要有一个不同就叫做参数列表不同。</p><p>重载是面向对象的一个基本特性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OverrideTest</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setPerson</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setPerson</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="comment">//set name</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setPerson</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="comment">//set name and age</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法的重写描述的是父类和子类之间的。当父类的功能无法满足子类的需求，可以在子类对方法进行重写</strong>。方法重写时， 方法名与形参列表必须一致。</p><p>如下代码，Person为父类，Student为子类，在Student中重写了dailyTask方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dailyTask</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;work eat sleep&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dailyTask</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;study eat sleep&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="34-接口与抽象类区别？"><a href="#34-接口与抽象类区别？" class="headerlink" title="34.接口与抽象类区别？"></a>34.接口与抽象类区别？</h2><p>1、<strong>语法层面</strong>上的区别</p><ul><li>抽象类可以有方法实现，而接口的方法中只能是抽象方法（Java 8 之后接口方法可以有默认实现）；</li><li>抽象类中的成员变量可以是各种类型的，接口中的成员变量只能是public static final类型；</li><li>接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法（Java 8之后接口可以有静态方法）；</li><li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li></ul><p>2、<strong>设计层面</strong>上的区别</p><ul><li>抽象层次不同。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口只是对类行为进行抽象。继承抽象类是一种”是不是”的关系，而接口实现则是 “有没有”的关系。如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而接口实现则是具备不具备的关系，比如鸟是否能飞。</li><li>继承抽象类的是具有相似特点的类，而实现接口的却可以不同的类。</li></ul><p>门和警报的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AlarmDoor</span> <span class="keyword">extends</span> <span class="title class_">Door</span> <span class="keyword">implements</span> <span class="title class_">Alarm</span> &#123;</span><br><span class="line">    <span class="comment">//code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BMWCar</span> <span class="keyword">extends</span> <span class="title class_">Car</span> <span class="keyword">implements</span> <span class="title class_">Alarm</span> &#123;</span><br><span class="line">    <span class="comment">//code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="35-常见的Exception有哪些？"><a href="#35-常见的Exception有哪些？" class="headerlink" title="35.常见的Exception有哪些？"></a>35.常见的Exception有哪些？</h2><p>常见的RuntimeException：</p><ol><li><code>ClassCastException</code> &#x2F;&#x2F;类型转换异常</li><li><code>IndexOutOfBoundsException</code> &#x2F;&#x2F;数组越界异常</li><li><code>NullPointerException</code> &#x2F;&#x2F;空指针</li><li><code>ArrayStoreException</code> &#x2F;&#x2F;数组存储异常</li><li><code>NumberFormatException</code> &#x2F;&#x2F;数字格式化异常</li><li><code>ArithmeticException</code> &#x2F;&#x2F;数学运算异常</li></ol><p>checked Exception：</p><ol><li><code>NoSuchFieldException</code> &#x2F;&#x2F;反射异常，没有对应的字段</li><li><code>ClassNotFoundException</code> &#x2F;&#x2F;类没有找到异常</li><li><code>IllegalAccessException</code> &#x2F;&#x2F;安全权限异常，可能是反射时调用了private方法</li></ol><h2 id="36-Error和Exception的区别？"><a href="#36-Error和Exception的区别？" class="headerlink" title="36.Error和Exception的区别？"></a>36.Error和Exception的区别？</h2><p><strong>Error</strong>：JVM 无法解决的严重问题，如栈溢出<code>StackOverflowError</code>、内存溢出<code>OOM</code>等。程序无法处理的错误。</p><p><strong>Exception</strong>：其它因编程错误或偶然的外在因素导致的一般性问题。可以在代码中进行处理。如：空指针异常、数组下标越界等。</p><h2 id="37-运行时异常和非运行时异常（checked）的区别？"><a href="#37-运行时异常和非运行时异常（checked）的区别？" class="headerlink" title="37.运行时异常和非运行时异常（checked）的区别？"></a>37.运行时异常和非运行时异常（checked）的区别？</h2><p><code>unchecked exception</code>包括<code>RuntimeException</code>和<code>Error</code>类，其他所有异常称为检查（checked）异常。</p><ol><li><code>RuntimeException</code>由程序错误导致，应该修正程序避免这类异常发生。</li><li><code>checked Exception</code>由具体的环境（读取的文件不存在或文件为空或sql异常）导致的异常。必须进行处理，不然编译不通过，可以catch或者throws。</li></ol><h2 id="38-throw和throws的区别？"><a href="#38-throw和throws的区别？" class="headerlink" title="38.throw和throws的区别？"></a>38.throw和throws的区别？</h2><ul><li><strong>throw</strong>：用于抛出一个具体的异常对象。</li><li><strong>throws</strong>：用在方法签名中，用于声明该方法可能抛出的异常。子类方法抛出的异常范围更加小，或者根本不抛异常。</li></ul><h2 id="39-通过故事讲清楚NIO"><a href="#39-通过故事讲清楚NIO" class="headerlink" title="39.通过故事讲清楚NIO"></a>39.通过故事讲清楚NIO</h2><p>下面通过一个例子来讲解下。</p><p>假设某银行只有10个职员。该银行的业务流程分为以下4个步骤：</p><p>1） 顾客填申请表（5分钟）；</p><p>2） 职员审核（1分钟）；</p><p>3） 职员叫保安去金库取钱（3分钟）；</p><p>4） 职员打印票据，并将钱和票据返回给顾客（1分钟）。</p><p>下面我们看看银行不同的工作方式对其工作效率到底有何影响。</p><p>首先是BIO方式。</p><p>每来一个顾客，马上由一位职员来接待处理，并且这个职员需要负责以上4个完整流程。当超过10个顾客时，剩余的顾客需要排队等候。</p><p>一个职员处理一个顾客需要10分钟（5+1+3+1）时间。一个小时（60分钟）能处理6个顾客，一共10个职员，那就是只能处理60个顾客。</p><p>可以看到银行职员的工作状态并不饱和，比如在第1步，其实是处于等待中。</p><p>这种工作其实就是BIO，每次来一个请求（顾客），就分配到线程池中由一个线程（职员）处理，如果超出了线程池的最大上限（10个），就扔到队列等待 。</p><p>那么如何提高银行的吞吐量呢？</p><p>思路就是：<strong>分而治之</strong>，将任务拆分开来，由专门的人负责专门的任务。</p><p>具体来讲，银行专门指派一名职员A，A的工作就是每当有顾客到银行，他就递上表格让顾客填写。每当有顾客填好表后，A就将其随机指派给剩余的9名职员完成后续步骤。</p><p>这种方式下，假设顾客非常多，职员A的工作处于饱和中，他不断的将填好表的顾客带到柜台处理。</p><p>柜台一个职员5分钟能处理完一个顾客，一个小时9名职员能处理：9*（60&#x2F;5）&#x3D;108。</p><p>可见工作方式的转变能带来效率的极大提升。</p><p>这种工作方式其实就NIO的思路。</p><p>下图是非常经典的NIO说明图，<code>mainReactor</code>线程负责监听server socket，接收新连接，并将建立的socket分派给<code>subReactor</code></p><p><code>subReactor</code>可以是一个线程，也可以是线程池，负责多路分离已连接的socket，读写网络数据。这里的读写网络数据可类比顾客填表这一耗时动作，对具体的业务处理功能，其扔给worker线程池完成</p><p>可以看到典型NIO有三类线程，分别是<code>mainReactor</code>线程、<code>subReactor</code>线程、<code>work</code>线程。</p><p>不同的线程干专业的事情，最终每个线程都没空着，系统的吞吐量自然就上去了。</p><p><img src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/20220423154450.png" alt="img"></p><p><strong>那这个流程还有没有什么可以提高的地方呢？</strong></p><p>可以看到，在这个业务流程里边第3个步骤，职员叫保安去金库取钱（3分钟）。这3分钟柜台职员是在等待中度过的，可以把这3分钟利用起来。</p><p>还是分而治之的思路，指派1个职员B来专门负责第3步骤。</p><p>每当柜台员工完成第2步时，就通知职员B来负责与保安沟通取钱。这时候柜台员工可以继续处理下一个顾客。</p><p>当职员B拿到钱之后，通知顾客钱已经到柜台了，让顾客重新排队处理，当柜台职员再次服务该顾客时，发现该顾客前3步已经完成，直接执行第4步即可。</p><p>在当今web服务中，经常需要通过RPC或者Http等方式调用第三方服务，这里对应的就是第3步，如果这步耗时较长，通过异步方式将能极大降低资源使用率。</p><p>NIO+异步的方式能让少量的线程做大量的事情。这适用于很多应用场景，比如代理服务、api服务、长连接服务等等。这些应用如果用同步方式将耗费大量机器资源。</p><p>不过虽然NIO+异步能提高系统吞吐量，但其并不能让一个请求的等待时间下降，相反可能会增加等待时间。</p><p>最后，NIO基本思想总结起来就是：<strong>分而治之，将任务拆分开来，由专门的人负责专门的任务</strong></p><h2 id="40-BIO-NIO-AIO区别的区别？"><a href="#40-BIO-NIO-AIO区别的区别？" class="headerlink" title="40.BIO&#x2F;NIO&#x2F;AIO区别的区别？"></a>40.BIO&#x2F;NIO&#x2F;AIO区别的区别？</h2><p><strong>同步阻塞IO</strong> : 用户进程发起一个IO操作以后，必须等待IO操作的真正完成后，才能继续运行。</p><p><strong>同步非阻塞IO</strong>: 客户端与服务器通过Channel连接，采用多路复用器轮询注册的<code>Channel</code>。提高吞吐量和可靠性。用户进程发起一个IO操作以后，可做其它事情，但用户进程需要轮询IO操作是否完成，这样造成不必要的CPU资源浪费。</p><p><strong>异步非阻塞IO</strong>: 非阻塞异步通信模式，NIO的升级版，采用异步通道实现异步通信，其read和write方法均是异步方法。用户进程发起一个IO操作，然后立即返回，等IO操作真正的完成以后，应用程序会得到IO操作完成的通知。类似Future模式。</p><h2 id="41-守护线程是什么？"><a href="#41-守护线程是什么？" class="headerlink" title="41.守护线程是什么？"></a>41.守护线程是什么？</h2><ul><li>守护线程是运行在后台的一种特殊进程。</li><li>它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。</li><li>在 Java 中垃圾回收线程就是特殊的守护线程。</li></ul><h2 id="42-Java支持多继承吗？"><a href="#42-Java支持多继承吗？" class="headerlink" title="42.Java支持多继承吗？"></a>42.Java支持多继承吗？</h2><p>java中，<strong>类不支持</strong>多继承。<strong>接口才支持</strong>多继承。接口的作用是拓展对象功能。当一个子接口继承了多个父接口时，说明子接口拓展了多个功能。当一个类实现该接口时，就拓展了多个的功能。</p><p>Java不支持多继承的原因：</p><ul><li>出于安全性的考虑，如果子类继承的多个父类里面有相同的方法或者属性，子类将不知道具体要继承哪个。</li><li>Java提供了接口和内部类以达到实现多继承功能，弥补单继承的缺陷。</li></ul><h2 id="43-如何实现对象克隆？"><a href="#43-如何实现对象克隆？" class="headerlink" title="43.如何实现对象克隆？"></a>43.如何实现对象克隆？</h2><ul><li>实现<code>Cloneable</code>接口，重写 <code>clone()</code> 方法。这种方式是浅拷贝，即如果类中属性有自定义引用类型，只拷贝引用，不拷贝引用指向的对象。如果对象的属性的Class也实现 <code>Cloneable</code> 接口，那么在克隆对象时也会克隆属性，即深拷贝。</li><li>结合序列化，深拷贝。</li><li>通过<code>org.apache.commons</code>中的工具类<code>BeanUtils</code>和<code>PropertyUtils</code>进行对象复制。</li></ul><h2 id="44-同步和异步的区别？"><a href="#44-同步和异步的区别？" class="headerlink" title="44.同步和异步的区别？"></a>44.同步和异步的区别？</h2><p>同步：发出一个调用时，在没有得到结果之前，该调用就不返回。</p><p>异步：在调用发出后，被调用者返回结果之后会通知调用者，或通过回调函数处理这个调用。</p><h2 id="45-阻塞和非阻塞的区别？"><a href="#45-阻塞和非阻塞的区别？" class="headerlink" title="45.阻塞和非阻塞的区别？"></a>45.阻塞和非阻塞的区别？</h2><p>阻塞和非阻塞关注的是线程的状态。</p><p>阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会恢复运行。</p><p>非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</p><blockquote><p>举个例子，理解下同步、阻塞、异步、非阻塞的区别：</p><p>同步就是烧开水，要自己来看开没开；异步就是水开了，然后水壶响了通知你水开了（回调通知）。阻塞是烧开水的过程中，你不能干其他事情，必须在旁边等着；非阻塞是烧开水的过程里可以干其他事情。</p></blockquote><h2 id="46-Java8的新特性有哪些？"><a href="#46-Java8的新特性有哪些？" class="headerlink" title="46.Java8的新特性有哪些？"></a>46.Java8的新特性有哪些？</h2><ul><li>Lambda 表达式：Lambda允许把函数作为一个方法的参数</li><li>Stream API ：新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中</li><li>默认方法：默认方法就是一个在接口里面有了一个实现的方法。</li><li>Optional 类 ：Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。</li><li>Date Time API ：加强对日期与时间的处理。</li></ul><blockquote><p><a href="https://github.com/Tyson0314/Java-learning/blob/master/Java/Java8%E6%96%B0%E7%89%B9%E6%80%A7.md">Java8 新特性总结</a></p></blockquote><h2 id="47-序列化和反序列化"><a href="#47-序列化和反序列化" class="headerlink" title="47.序列化和反序列化"></a>47.序列化和反序列化</h2><ul><li>序列化：把对象转换为字节序列的过程称为对象的序列化.</li><li>反序列化：把字节序列恢复为对象的过程称为对象的反序列化.</li></ul><h2 id="48-什么时候需要用到序列化和反序列化呢"><a href="#48-什么时候需要用到序列化和反序列化呢" class="headerlink" title="48.什么时候需要用到序列化和反序列化呢?"></a>48.什么时候需要用到序列化和反序列化呢?</h2><p>当我们只在本地 JVM 里运行下 Java 实例，这个时候是不需要什么序列化和反序列化的，但当我们需要将内存中的对象持久化到磁盘，数据库中时，当我们需要与浏览器进行交互时，当我们需要实现 RPC 时，这个时候就需要序列化和反序列化了.</p><p>前两个需要用到序列化和反序列化的场景，是不是让我们有一个很大的疑问? 我们在与浏览器交互时，还有将内存中的对象持久化到数据库中时，好像都没有去进行序列化和反序列化，因为我们都没有实现 Serializable 接口，但一直正常运行.</p><p>下面先给出结论:</p><p><strong>只要我们对内存中的对象进行持久化或网络传输，这个时候都需要序列化和反序列化.</strong></p><p>理由:</p><p>服务器与浏览器交互时真的没有用到 Serializable 接口吗? JSON 格式实际上就是将一个对象转化为字符串，所以服务器与浏览器交互时的数据格式其实是字符串，我们来看来 String 类型的源码:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> final <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> java.<span class="property">io</span>.<span class="property">Serializable</span>，<span class="title class_">Comparable</span>&lt;<span class="title class_">String</span>&gt;，<span class="title class_">CharSequence</span> &#123;</span><br><span class="line">    <span class="regexp">/\*\* The value is used for character storage. \*/</span></span><br><span class="line">    <span class="keyword">private</span> final char value\[\];</span><br><span class="line"></span><br><span class="line">    <span class="regexp">/\*\* Cache the hash code for the string \*/</span></span><br><span class="line">    <span class="keyword">private</span> int hash; <span class="comment">// Default to 0</span></span><br><span class="line"></span><br><span class="line">    <span class="regexp">/\*\* use serialVersionUID from JDK 1.0.2 for interoperability \*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final long serialVersionUID = -6849794470754667710L;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>String 类型实现了 Serializable 接口，并显示指定 serialVersionUID 的值.</p><p>然后我们再来看对象持久化到数据库中时的情况，Mybatis 数据库映射文件里的 insert 代码:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert <span class="built_in">id</span>=<span class="string">&quot;insertUser&quot;</span> parameterType=<span class="string">&quot;org.tyshawn.bean.User&quot;</span>&gt;</span><br><span class="line">    INSERT INTO t\_user(name，age) VALUES (<span class="comment">#&#123;name&#125;，#&#123;age&#125;)</span></span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure><p>实际上我们并不是将整个对象持久化到数据库中，而是将对象中的属性持久化到数据库中，而这些属性（如Date&#x2F;String）都实现了 Serializable 接口。</p><h2 id="49-实现序列化和反序列化为什么要实现-Serializable-接口"><a href="#49-实现序列化和反序列化为什么要实现-Serializable-接口" class="headerlink" title="49.实现序列化和反序列化为什么要实现 Serializable 接口?"></a>49.实现序列化和反序列化为什么要实现 Serializable 接口?</h2><p>在 Java 中实现了 Serializable 接口后， JVM 在类加载的时候就会发现我们实现了这个接口，然后在初始化实例对象的时候就会在底层帮我们实现序列化和反序列化。</p><p>如果被写对象类型不是String、数组、Enum，并且没有实现Serializable接口，那么在进行序列化的时候，将抛出NotSerializableException。源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// remaining cases</span></span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">    writeString((String) obj, unshared);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cl.isArray()) &#123;</span><br><span class="line">    writeArray(obj, desc, unshared);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Enum) &#123;</span><br><span class="line">    writeEnum((Enum&lt;?&gt;) obj, desc, unshared);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Serializable) &#123;</span><br><span class="line">    writeOrdinaryObject(obj, desc, unshared);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NotSerializableException</span>(</span><br><span class="line">            cl.getName() + <span class="string">&quot;\n&quot;</span> + debugInfoStack.toString());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NotSerializableException</span>(cl.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="50-实现-Serializable-接口之后，为什么还要显示指定-serialVersionUID-的值"><a href="#50-实现-Serializable-接口之后，为什么还要显示指定-serialVersionUID-的值" class="headerlink" title="50.实现 Serializable 接口之后，为什么还要显示指定 serialVersionUID 的值?"></a>50.实现 Serializable 接口之后，为什么还要显示指定 serialVersionUID 的值?</h2><p>如果不显示指定 serialVersionUID，JVM 在序列化时会根据属性自动生成一个 serialVersionUID，然后与属性一起序列化，再进行持久化或网络传输. 在反序列化时，JVM 会再根据属性自动生成一个新版 serialVersionUID，然后将这个新版 serialVersionUID 与序列化时生成的旧版 serialVersionUID 进行比较，如果相同则反序列化成功，否则报错.</p><p>如果显示指定了 serialVersionUID，JVM 在序列化和反序列化时仍然都会生成一个 serialVersionUID，但值为我们显示指定的值，这样在反序列化时新旧版本的 serialVersionUID 就一致了.</p><p>如果我们的类写完后不再修改，那么不指定serialVersionUID，不会有问题，但这在实际开发中是不可能的，我们的类会不断迭代，一旦类被修改了，那旧对象反序列化就会报错。 所以在实际开发中，我们都会显示指定一个 serialVersionUID。</p><h2 id="51-static-属性为什么不会被序列化"><a href="#51-static-属性为什么不会被序列化" class="headerlink" title="51.static 属性为什么不会被序列化?"></a>51.static 属性为什么不会被序列化?</h2><p>因为序列化是针对对象而言的，而 static 属性优先于对象存在，随着类的加载而加载，所以不会被序列化.</p><p>看到这个结论，是不是有人会问，serialVersionUID 也被 static 修饰，为什么 serialVersionUID 会被序列化? 其实 serialVersionUID 属性并没有被序列化，JVM 在序列化对象时会自动生成一个 serialVersionUID，然后将我们显示指定的 serialVersionUID 属性值赋给自动生成的 serialVersionUID.</p><h2 id="52-transient关键字的作用？"><a href="#52-transient关键字的作用？" class="headerlink" title="52.transient关键字的作用？"></a>52.transient关键字的作用？</h2><p>Java语言的关键字，变量修饰符，如果用transient声明一个实例变量，当对象存储时，它的值不需要维持。</p><p>也就是说被transient修饰的成员变量，在序列化的时候其值会被忽略，在被反序列化后， transient 变量的值被设为初始值， 如 int 型的是 0，对象型的是 null。</p><h2 id="53-什么是反射？"><a href="#53-什么是反射？" class="headerlink" title="53.什么是反射？"></a>53.什么是反射？</h2><p>动态获取的信息以及动态调用对象的方法的功能称为Java语言的反射机制。</p><p>在运行状态中，对于任意一个类，能够知道这个类的所有属性和方法。对于任意一个对象，能够调用它的任意一个方法和属性。</p><h2 id="54-反射有哪些应用场景呢？"><a href="#54-反射有哪些应用场景呢？" class="headerlink" title="54.反射有哪些应用场景呢？"></a>54.反射有哪些应用场景呢？</h2><ol><li>JDBC连接数据库时使用<code>Class.forName()</code>通过反射加载数据库的驱动程序</li><li>Eclispe、IDEA等开发工具利用反射动态解析对象的类型与结构，动态提示对象的属性和方法</li><li>Web服务器中利用反射调用了Sevlet的<code>service</code>方法</li><li>JDK动态代理底层依赖反射实现</li></ol><h2 id="55-讲讲什么是泛型？"><a href="#55-讲讲什么是泛型？" class="headerlink" title="55.讲讲什么是泛型？"></a>55.讲讲什么是泛型？</h2><p>Java泛型是JDK 5中引⼊的⼀个新特性， 允许在定义类和接口的时候使⽤类型参数。声明的类型参数在使⽤时⽤具体的类型来替换。</p><p>泛型最⼤的好处是可以提⾼代码的复⽤性。以List接口为例，我们可以将String、 Integer等类型放⼊List中， 如不⽤泛型， 存放String类型要写⼀个List接口， 存放Integer要写另外⼀个List接口， 泛型可以很好的解决这个问题。</p><h2 id="56-如何停止一个正在运行的线程？"><a href="#56-如何停止一个正在运行的线程？" class="headerlink" title="56.如何停止一个正在运行的线程？"></a>56.如何停止一个正在运行的线程？</h2><p>有几种方式。</p><p>1、<strong>使用线程的stop方法</strong>。</p><p>使用stop()方法可以强制终止线程。不过stop是一个被废弃掉的方法，不推荐使用。</p><p>使用Stop方法，会一直向上传播ThreadDeath异常，从而使得目标线程解锁所有锁住的监视器，即释放掉所有的对象锁。使得之前被锁住的对象得不到同步的处理，因此可能会造成数据不一致的问题。</p><p>2、<strong>使用interrupt方法中断线程</strong>，该方法只是告诉线程要终止，但最终何时终止取决于计算机。调用interrupt方法仅仅是在当前线程中打了一个停止的标记，并不是真的停止线程。</p><p>接着调用 Thread.currentThread().isInterrupted()方法，可以用来判断当前线程是否被终止，通过这个判断我们可以做一些业务逻辑处理，通常如果isInterrupted返回true的话，会抛一个中断异常，然后通过try-catch捕获。</p><p>3、<strong>设置标志位</strong></p><p>设置标志位，当标识位为某个值时，使线程正常退出。设置标志位是用到了共享变量的方式，为了保证共享变量在内存中的可见性，可以使用volatile修饰它，这样的话，变量取值始终会从主存中获取最新值。</p><p>但是这种volatile标记共享变量的方式，在线程发生阻塞时是无法完成响应的。比如调用Thread.sleep() 方法之后，线程处于不可运行状态，即便是主线程修改了共享变量的值，该线程此时根本无法检查循环标志，所以也就无法实现线程中断。</p><p>因此，interrupt() 加上手动抛异常的方式是目前中断一个正在运行的线程<strong>最为正确</strong>的方式了。</p><h2 id="57-什么是跨域？"><a href="#57-什么是跨域？" class="headerlink" title="57.什么是跨域？"></a>57.什么是跨域？</h2><p>简单来讲，跨域是指从一个域名的网页去请求另一个域名的资源。由于有<strong>同源策略</strong>的关系，一般是不允许这么直接访问的。但是，很多场景经常会有跨域访问的需求，比如，在前后端分离的模式下，前后端的域名是不一致的，此时就会发生跨域问题。</p><p><strong>那什么是同源策略呢</strong>？</p><p>所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。</p><p>同源策略限制以下几种行为：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. Cookie、LocalStorage 和 IndexDB 无法读取</span><br><span class="line"><span class="number">2</span>. DOM 和 <span class="keyword">Js对象无法获得</span></span><br><span class="line"><span class="keyword"></span><span class="number">3</span>. AJAX 请求不能发送</span><br></pre></td></tr></table></figure><p><strong>为什么要有同源策略</strong>？</p><p>举个例子，假如你刚刚在网银输入账号密码，查看了自己的余额，然后再去访问其他带颜色的网站，这个网站可以访问刚刚的网银站点，并且获取账号密码，那后果可想而知。因此，从安全的角度来讲，同源策略是有利于保护网站信息的。</p><h2 id="58-跨域问题怎么解决呢？"><a href="#58-跨域问题怎么解决呢？" class="headerlink" title="58.跨域问题怎么解决呢？"></a>58.跨域问题怎么解决呢？</h2><p>嗯，有以下几种方法：</p><p><strong>CORS</strong>，跨域资源共享</p><p>CORS（Cross-origin resource sharing），跨域资源共享。CORS 其实是浏览器制定的一个规范，浏览器会自动进行 CORS 通信，它的实现主要在服务端，通过一些 HTTP Header 来限制可以访问的域，例如页面 A 需要访问 B 服务器上的数据，如果 B 服务器 上声明了允许 A 的域名访问，那么从 A 到 B 的跨域请求就可以完成。</p><p><strong>@CrossOrigin注解</strong></p><p>如果项目使用的是Springboot，可以在Controller类上添加一个 @CrossOrigin(origins &#x3D;”*”) 注解就可以实现对当前controller 的跨域访问了，当然这个标签也可以加到方法上，或者直接加到入口类上对所有接口进行跨域处理。注意SpringMVC的版本要在4.2或以上版本才支持@CrossOrigin。</p><p><strong>nginx反向代理接口跨域</strong></p><p>nginx反向代理跨域原理如下： 首先同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨越问题。</p><p>nginx反向代理接口跨域实现思路如下：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// proxy服务器</span></span><br><span class="line">server &#123;</span><br><span class="line">    listen       <span class="number">81</span>;</span><br><span class="line">    server_name  www.<span class="property">domain1</span>.<span class="property">com</span>;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass   <span class="attr">http</span>:<span class="comment">//www.domain2.com:8080;  #反向代理</span></span><br><span class="line">        proxy_cookie_domain www.<span class="property">domain2</span>.<span class="property">com</span> www.<span class="property">domain1</span>.<span class="property">com</span>; #修改cookie里域名</span><br><span class="line">        index  index.<span class="property">html</span> index.<span class="property">htm</span>;</span><br><span class="line">        </span><br><span class="line">        add_header <span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Origin</span> <span class="attr">http</span>:<span class="comment">//www.domain1.com;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们的前端代理只要访问 http:<a href="http://www.domain1.com:81/*%E5%B0%B1%E5%8F%AF%E4%BB%A5%E4%BA%86%E3%80%82">www.domain1.com:81/*就可以了。</a></p><p><strong>通过jsonp跨域</strong></p><p>通常为了减轻web服务器的负载，我们把js、css，img等静态资源分离到另一台独立域名的服务器上，在html页面中再通过相应的标签从不同域名下加载静态资源，这是浏览器允许的操作，基于此原理，我们可以通过动态创建script，再请求一个带参网址实现跨域通信。</p><h2 id="59-设计接口要注意什么"><a href="#59-设计接口要注意什么" class="headerlink" title="59.设计接口要注意什么?"></a>59.设计接口要注意什么?</h2><ol><li><strong>接口参数校验</strong>。接口必须校验参数，比如入参是否允许为空，入参长度是否符合预期。</li><li>设计接口时，充分考虑接口的<strong>可扩展性</strong>。思考接口是否可以复用，怎样保持接口的可扩展性。</li><li><strong>串行调用考虑改并行调用</strong>。比如设计一个商城首页接口，需要查商品信息、营销信息、用户信息等等。如果是串行一个一个查，那耗时就比较大了。这种场景是可以改为并行调用的，降低接口耗时。</li><li>接口是否需要<strong>防重</strong>处理。涉及到数据库修改的，要考虑防重处理，可以使用数据库防重表，以唯一流水号作为唯一索引。</li><li><strong>日志打印全面</strong>，入参出参，接口耗时，记录好日志，方便甩锅。</li><li>修改旧接口时，注意<strong>兼容性设计</strong>。</li><li><strong>异常处理得当</strong>。使用finally关闭流资源、使用log打印而不是e.printStackTrace()、不要吞异常等等</li><li>是否需要考虑<strong>限流</strong>。限流为了保护系统，防止流量洪峰超过系统的承载能力。</li></ol><h2 id="60-过滤器和拦截器有什么区别？"><a href="#60-过滤器和拦截器有什么区别？" class="headerlink" title="60.过滤器和拦截器有什么区别？"></a>60.过滤器和拦截器有什么区别？</h2><p>1、<strong>实现原理不同</strong>。</p><p>过滤器和拦截器底层实现不同。过滤器是基于函数回调的，拦截器是基于Java的反射机制（动态代理）实现的。一般自定义的过滤器中都会实现一个doFilter()方法，这个方法有一个FilterChain参数，而实际上它是一个回调接口。</p><p>2、<strong>使用范围不同</strong>。</p><p>过滤器实现的是 javax.servlet.Filter 接口，而这个接口是在Servlet规范中定义的，也就是说过滤器Filter的使用要依赖于Tomcat等容器，导致它只能在web程序中使用。而拦截器是一个Spring组件，并由Spring容器管理，并不依赖Tomcat等容器，是可以单独使用的。拦截器不仅能应用在web程序中，也可以用于Application、Swing等程序中。</p><p>3、<strong>使用的场景不同</strong>。</p><p>因为拦截器更接近业务系统，所以拦截器主要用来实现项目中的业务判断的，比如：日志记录、权限判断等业务。而过滤器通常是用来实现通用功能过滤的，比如：敏感词过滤、响应数据压缩等功能。</p><p>4、<strong>触发时机不同</strong>。</p><p>过滤器Filter是在请求进入容器后，但在进入servlet之前进行预处理，请求结束是在servlet处理完以后。</p><p>拦截器 Interceptor 是在请求进入servlet后，在进入Controller之前进行预处理的，Controller 中渲染了对应的视图之后请求结束。</p><p>5、<strong>拦截的请求范围不同</strong>。</p><p>请求的执行顺序是：请求进入容器 -&gt; 进入过滤器 -&gt; 进入 Servlet -&gt; 进入拦截器 -&gt; 执行控制器。可以看到过滤器和拦截器的执行时机也是不同的，过滤器会先执行，然后才会执行拦截器，最后才会进入真正的要调用的方法。</p><blockquote><p>参考链接：<a href="https://segmentfault.com/a/1190000022833940">https://segmentfault.com/a/1190000022833940</a></p></blockquote><h2 id="61-对接第三方接口要考虑什么？"><a href="#61-对接第三方接口要考虑什么？" class="headerlink" title="61.对接第三方接口要考虑什么？"></a>61.对接第三方接口要考虑什么？</h2><p>嗯，需要考虑以下几点：</p><ol><li>确认接口对接的<strong>网络协议</strong>，是https&#x2F;http或者自定义的私有协议等。</li><li>约定好<strong>数据传参、响应格式</strong>（如application&#x2F;json），弱类型对接强类型语言时要特别注意</li><li><strong>接口安全</strong>方面，要确定身份校验方式，使用token、证书校验等</li><li>确认是否需要接口调用失败后的<strong>重试</strong>机制，保证数据传输的最终一致性。</li><li><strong>日志记录要全面</strong>。接口出入参数，以及解析之后的参数值，都要用日志记录下来，方便定位问题（甩锅）。</li></ol><p>参考：<a href="https://blog.csdn.net/gzt19881123/article/details/108791034">https://blog.csdn.net/gzt19881123/article/details/108791034</a></p><h2 id="62-后端接口性能优化有哪些方法？"><a href="#62-后端接口性能优化有哪些方法？" class="headerlink" title="62.后端接口性能优化有哪些方法？"></a>62.后端接口性能优化有哪些方法？</h2><p>有以下这些方法：</p><p>1、<strong>优化索引</strong>。给where条件的关键字段，或者<code>order by</code>后面的排序字段，加索引。</p><p>2、<strong>优化sql语句</strong>。比如避免使用select *、批量操作、避免深分页、提升group by的效率等</p><p>3、<strong>避免大事务</strong>。使用@Transactional注解这种声明式事务的方式提供事务功能，容易造成大事务，引发其他的问题。应该避免在事务中一次性处理太多数据，将一些跟事务无关的逻辑放到事务外面执行。</p><p>4、<strong>异步处理</strong>。剥离主逻辑和副逻辑，副逻辑可以异步执行，异步写库。比如用户购买的商品发货了，需要发短信通知，短信通知是副流程，可以异步执行，以免影响主流程的执行。</p><p>5、<strong>降低锁粒度</strong>。在并发场景下，多个线程同时修改数据，造成数据不一致的情况。这种情况下，一般会加锁解决。但如果锁加得不好，导致锁的粒度太粗，也会非常影响接口性能。</p><p>6、<strong>加缓存</strong>。如果表数据量非常大的话，直接从数据库查询数据，性能会非常差。可以使用Redis<code>和</code>memcached提升查询性能，从而提高接口性能。</p><p>7、<strong>分库分表</strong>。当系统发展到一定的阶段，用户并发量大，会有大量的数据库请求，需要占用大量的数据库连接，同时会带来磁盘IO的性能瓶颈问题。或者数据库表数据非常大，SQL查询即使走了索引，也很耗时。这时，可以通过分库分表解决。分库用于解决数据库连接资源不足问题，和磁盘IO的性能瓶颈问题。分表用于解决单表数据量太大，sql语句查询数据时，即使走了索引也非常耗时问题。</p><p>8、<strong>避免在循环中查询数据库</strong>。循环查询数据库，非常耗时，最好能在一次查询中获取所有需要的数据。</p><h2 id="63-为什么在阿里巴巴Java开发手册中强制要求使用包装类型定义属性呢？"><a href="#63-为什么在阿里巴巴Java开发手册中强制要求使用包装类型定义属性呢？" class="headerlink" title="63.为什么在阿里巴巴Java开发手册中强制要求使用包装类型定义属性呢？"></a>63.为什么在阿里巴巴Java开发手册中强制要求使用包装类型定义属性呢？</h2><p>嗯，以布尔字段为例，当我们没有设置对象的字段的值的时候，Boolean类型的变量会设置默认值为<code>null</code>，而boolean类型的变量会设置默认值为<code>false</code>。</p><p>也就是说，包装类型的默认值都是null，而基本数据类型的默认值是一个固定值，如boolean是false，byte、short、int、long是0，float是0.0f等。</p><p>举一个例子，比如有一个扣费系统，扣费时需要从外部的定价系统中读取一个费率的值，我们预期该接口的返回值中会包含一个浮点型的费率字段。当我们取到这个值得时候就使用公式：金额*费率&#x3D;费用 进行计算，计算结果进行划扣。</p><p>如果由于计费系统异常，他可能会返回个默认值，如果这个字段是Double类型的话，该默认值为null，如果该字段是double类型的话，该默认值为0.0。</p><p>如果扣费系统对于该费率返回值没做特殊处理的话，拿到null值进行计算会直接报错，阻断程序。拿到0.0可能就直接进行计算，得出接口为0后进行扣费了。这种异常情况就无法被感知。</p><p><strong>那我可以对0.0做特殊判断，如果是0就阻断报错，这样是否可以呢？</strong></p><p>不对，这时候就会产生一个问题，如果允许费率是0的场景又怎么处理呢？</p><p>使用基本数据类型只会让方案越来越复杂，坑越来越多。</p><p>这种使用包装类型定义变量的方式，通过异常来阻断程序，进而可以被识别到这种线上问题。如果使用基本数据类型的话，系统可能不会报错，进而认为无异常。</p><p>因此，建议在POJO和RPC的返回值中使用包装类型。</p><h2 id="64-8招让接口性能提升100倍"><a href="#64-8招让接口性能提升100倍" class="headerlink" title="64.8招让接口性能提升100倍"></a>64.8招让接口性能提升100倍</h2><p><strong>池化思想</strong></p><p>如果你每次需要用到线程，都去创建，就会有增加一定的耗时，而线程池可以重复利用线程，避免不必要的耗时。</p><p>比如<code>TCP</code>三次握手，它为了减少性能损耗，引入了<code>Keep-Alive长连接</code>，避免频繁的创建和销毁连接。</p><p><strong>拒绝阻塞等待</strong></p><p>如果你调用一个系统<code>B</code>的接口，但是它处理业务逻辑，耗时需要<code>10s</code>甚至更多。然后你是一直<strong>阻塞等待，直到系统B的下游接口返回</strong>，再继续你的下一步操作吗？这样<strong>显然不合理</strong>。</p><p>参考<strong>IO多路复用模型</strong>。即我们不用阻塞等待系统<code>B</code>的接口，而是先去做别的操作。等系统<code>B</code>的接口处理完，通过<strong>事件回调</strong>通知，我们接口收到通知再进行对应的业务操作即可。</p><p><strong>远程调用由串行改为并行</strong></p><p>比如设计一个商城首页接口，需要查商品信息、营销信息、用户信息等等。如果是串行一个一个查，那耗时就比较大了。这种场景是可以改为并行调用的，降低接口耗时。</p><p><strong>锁粒度避免过粗</strong></p><p>在高并发场景，为了防止<strong>超卖等情况</strong>，我们经常需要<strong>加锁来保护共享资源</strong>。但是，如果加锁的粒度过粗，是很影响接口性能的。</p><p>不管你是<code>synchronized</code>加锁还是<code>redis</code>分布式锁，只需要在共享临界资源加锁即可，不涉及共享资源的，就不必要加锁。</p><p><strong>耗时操作，考虑放到异步执行</strong></p><p>耗时操作，考虑用<strong>异步处理</strong>，这样可以降低接口耗时。比如用户注册成功后，短信邮件通知，是可以异步处理的。</p><p><strong>使用缓存</strong></p><p>把要查的数据，提前放好到缓存里面，需要时，<strong>直接查缓存，而避免去查数据库或者计算的过程</strong>。</p><p><strong>提前初始化到缓存</strong></p><p>预取思想很容易理解，就是<strong>提前把要计算查询的数据，初始化到缓存</strong>。如果你在未来某个时间需要用到某个经过复杂计算的数据，<strong>才实时去计算的话，可能耗时比较大</strong>。这时候，我们可以采取预取思想，<strong>提前把将来可能需要的数据计算好，放到缓存中</strong>，等需要的时候，去缓存取就行。这将大幅度提高接口性能。</p><p><strong>压缩传输内容</strong></p><p>压缩传输内容，传输报文变得更小，因此传输会更快。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring</title>
      <link href="/2024/03/21/Spring/"/>
      <url>/2024/03/21/Spring/</url>
      
        <content type="html"><![CDATA[<h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a><strong>1.简介</strong></h3><p><a href="https://docs.spring.io/spring-framework/reference">https://docs.spring.io/spring-framework/reference</a></p><h3 id="2-优点"><a href="#2-优点" class="headerlink" title="2.优点"></a><strong>2.优点</strong></h3><ul><li>Spring是一个开源的免费的框架（容器）。</li><li>Spring是一个轻量级，非入侵式的框架</li><li>控制反转（IOC），面向切面编程（AOP）</li><li>支持事务的处理，对框架整合的支持</li></ul><h3 id="3-组成"><a href="#3-组成" class="headerlink" title="3.组成"></a><strong>3.组成</strong></h3><p><img src="/../UpPictures/SpringPictures/image-20240321163406903.png" alt="image-20240321163406903"></p><h3 id="4-拓展"><a href="#4-拓展" class="headerlink" title="4.拓展"></a><strong>4.拓展</strong></h3><p>现代化的java开发，说白了就是基于Spring的开发。</p><p>Your App –&gt; Spring Boot –&gt;Spring Cloud –&gt; Spring Cloud Data Flow</p><pre><code>                    (构建一切)           (协调一切)                    (连接一切)</code></pre><ul><li><p>Spring Boot</p><ul><li>一个快速开发的脚手架</li><li>基于SpringBoot可以快速开发单个微服务</li><li>约定大于配置</li></ul></li><li><p>Spring Cloud </p><ul><li>SpringCloud是基于SpringBoot实现的</li></ul></li></ul><p>因为现在大多数公司都在使用SpringBoot进行快速开发，学习SpringBoot的前提，需要完全掌握Spring及SpringMVC。（承上启下的作用）</p><p>弊端：发展了太久之后，违背了原来的理念。配置十分繁琐，人称：“配置地狱”</p><h3 id="5-IOC理论推导"><a href="#5-IOC理论推导" class="headerlink" title="5.IOC理论推导"></a><strong>5.IOC理论推导</strong></h3><p><strong>实现一：</strong></p><ol><li><p>UserDao接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package com.chabai.dao;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author 刘晔</span><br><span class="line"> * @version 1.0</span><br><span class="line"> * description:</span><br><span class="line"> */</span><br><span class="line">public interface UserDao &#123;</span><br><span class="line">    void getUser();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>UserDaoImpl实现类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package com.chabai.dao;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author 刘晔</span><br><span class="line"> * @version 1.0</span><br><span class="line"> * description:</span><br><span class="line"> */</span><br><span class="line">public class UserDaoImpl implements UserDao&#123;</span><br><span class="line">    public void getUser() &#123;</span><br><span class="line">        System.out.println(&quot;默认获取用户的数据&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package com.chabai.dao;</span><br><span class="line"></span><br><span class="line">import java.sql.SQLOutput;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author 刘晔</span><br><span class="line"> * @version 1.0</span><br><span class="line"> * description:</span><br><span class="line"> */</span><br><span class="line">public class UserDaoMysqlImpl implements UserDao&#123;</span><br><span class="line">    public void getUser() &#123;</span><br><span class="line">        System.out.println(&quot;Mysql获取用户数&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>UserService业务接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package com.chabai.service;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author 刘晔</span><br><span class="line"> * @version 1.0</span><br><span class="line"> * description:</span><br><span class="line"> */</span><br><span class="line">public interface UserService &#123;</span><br><span class="line">    void getUser();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>UserServiceImpl业务实现类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package com.chabai.service;</span><br><span class="line"></span><br><span class="line">import com.chabai.dao.UserDao;</span><br><span class="line">import com.chabai.dao.UserDaoImpl;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author 刘晔</span><br><span class="line"> * @version 1.0</span><br><span class="line"> * description:</span><br><span class="line"> */</span><br><span class="line">public class UserServiceImpl implements UserService &#123;</span><br><span class="line"></span><br><span class="line">      //1.用户想用什么我们总是需要改动对应UserServiceImpl代码，代价太大了</span><br><span class="line">      private UserDao userDao = new UserDaoImpl();</span><br><span class="line">      或private UserDao userDao = new UserDaoMysqlImpl();</span><br><span class="line">      或private UserDao userDao = new UserDaoOracleImpl();</span><br><span class="line">    </span><br><span class="line">    public void getUser() &#123;</span><br><span class="line">        userDao.getUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import com.chabai.dao.UserDao;</span><br><span class="line">import com.chabai.dao.UserDaoImpl;</span><br><span class="line">import com.chabai.dao.UserDaoMysqlImpl;</span><br><span class="line">import com.chabai.dao.UserDaoOracleImpl;</span><br><span class="line">import com.chabai.service.UserServiceImpl;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author 刘晔</span><br><span class="line"> * @version 1.0</span><br><span class="line"> * description:</span><br><span class="line"> */</span><br><span class="line">public class MyTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        //用户实际调用的是业务层，dao层他们不需要实际接触</span><br><span class="line">        UserServiceImpl userService = new UserServiceImpl();</span><br><span class="line">        userService.getUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>实现二：</strong></p><ol><li><p>UserDao接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package com.chabai.dao;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author 刘晔</span><br><span class="line"> * @version 1.0</span><br><span class="line"> * description:</span><br><span class="line"> */</span><br><span class="line">public interface UserDao &#123;</span><br><span class="line">    void getUser();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>UserDaoImpl实现类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package com.chabai.dao;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author 刘晔</span><br><span class="line"> * @version 1.0</span><br><span class="line"> * description:</span><br><span class="line"> */</span><br><span class="line">public class UserDaoImpl implements UserDao&#123;</span><br><span class="line">    public void getUser() &#123;</span><br><span class="line">        System.out.println(&quot;默认获取用户的数据&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package com.chabai.dao;</span><br><span class="line"></span><br><span class="line">import java.sql.SQLOutput;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author 刘晔</span><br><span class="line"> * @version 1.0</span><br><span class="line"> * description:</span><br><span class="line"> */</span><br><span class="line">public class UserDaoMysqlImpl implements UserDao&#123;</span><br><span class="line">    public void getUser() &#123;</span><br><span class="line">        System.out.println(&quot;Mysql获取用户数&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>UserService业务接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package com.chabai.service;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author 刘晔</span><br><span class="line"> * @version 1.0</span><br><span class="line"> * description:</span><br><span class="line"> */</span><br><span class="line">public interface UserService &#123;</span><br><span class="line">    void getUser();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>UserServiceImpl业务实现类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package com.chabai.service;</span><br><span class="line"></span><br><span class="line">import com.chabai.dao.UserDao;</span><br><span class="line">import com.chabai.dao.UserDaoImpl;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author 刘晔</span><br><span class="line"> * @version 1.0</span><br><span class="line"> * description:</span><br><span class="line"> */</span><br><span class="line">public class UserServiceImpl implements UserService &#123;</span><br><span class="line"></span><br><span class="line">    //优化:利用set实现动态值的注入</span><br><span class="line">    //之前，程序是主动创建对象，控制权在程序员手上</span><br><span class="line">    //使用了set注入后，程序不再具有主动性，而是变成了被动接受对象</span><br><span class="line">    private UserDao userDao;</span><br><span class="line">    public void setUserDao(UserDao userDao) &#123;</span><br><span class="line">        this.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void getUser() &#123;</span><br><span class="line">        userDao.getUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import com.chabai.dao.UserDao;</span><br><span class="line">import com.chabai.dao.UserDaoImpl;</span><br><span class="line">import com.chabai.dao.UserDaoMysqlImpl;</span><br><span class="line">import com.chabai.dao.UserDaoOracleImpl;</span><br><span class="line">import com.chabai.service.UserServiceImpl;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author 刘晔</span><br><span class="line"> * @version 1.0</span><br><span class="line"> * description:</span><br><span class="line"> */</span><br><span class="line">public class MyTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        UserServiceImpl userService = new UserServiceImpl();</span><br><span class="line">        userService.setUserDao(new UserDaoOracleImpl());//改这里的对象即可</span><br><span class="line">        userService.getUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>分析：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//优化:利用set实现动态值的注入</span></span><br><span class="line"><span class="comment">//之前，程序是主动创建对象，控制权在程序员手上</span></span><br><span class="line"><span class="comment">//使用了set注入后，程序不再具有主动性，而是变成了被动接受对象</span></span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种思想，从本质上解决了问题，我们程序员不用再去管理对下岗的创建了。系统的耦合性大大降低，可以更加专注的在业务的实现上，这是ioc的原型！</p><h3 id="6-ioc本质"><a href="#6-ioc本质" class="headerlink" title="6.ioc本质"></a><strong>6.ioc本质</strong></h3><p>控制反转IoC(Inversion of Control),是一种设计思想，DI(依赖注入)是实现IoC的一种方法，也有人认为DI只是IoC的另一种说法。没有IoC的程序中，我们使用面向对象编程，对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创见转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。</p><p>采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把两者合为一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。</p><p><strong>控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器，其实现方法是依赖注入（Dependency Injection,DI）。</strong></p><h3 id="7-HelloSpring"><a href="#7-HelloSpring" class="headerlink" title="7.HelloSpring"></a><strong>7.HelloSpring</strong></h3><blockquote><p>导入Jar包</p></blockquote><p>注 : spring 需要导入commons-logging进行日志记录 . 我们利用maven , 他会自动下载对应的依赖项 .</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;5.1.10.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><blockquote><p>编写代码</p></blockquote><p>1、编写一个Hello实体类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Hello &#123;</span><br><span class="line">   private String name;</span><br><span class="line"></span><br><span class="line">   public String getName() &#123;</span><br><span class="line">       return name;</span><br><span class="line">  &#125;</span><br><span class="line">   public void setName(String name) &#123;</span><br><span class="line">       this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   public void show()&#123;</span><br><span class="line">       System.out.println(&quot;Hello,&quot;+ name );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、编写我们的spring文件 , 这里我们命名为beans.xml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!--bean就是java对象 , 由Spring创建和管理--&gt;</span><br><span class="line">   &lt;bean id=&quot;hello&quot; class=&quot;com.kuang.pojo.Hello&quot;&gt;</span><br><span class="line">       &lt;!--value:具体的值（基本数据类型）</span><br><span class="line">           ref:引用Spring中已经存在的对象</span><br><span class="line">       --&gt;</span><br><span class="line">       &lt;property name=&quot;name&quot; value=&quot;Spring&quot;/&gt;&lt;!--对应Hello中的setName方法--&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">以下示例显示了基于 XML 的配置元数据的基本结构：</span><br><span class="line">xml</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line">  </span><br><span class="line">    &lt;!--该属性是一个字符串，用于标识单个 Bean 定义。id     </span><br><span class="line">    该属性定义 Bean 的类型，并使用完全限定的 类名。class</span><br><span class="line">    --&gt;</span><br><span class="line">&lt;bean id=&quot;...&quot; class=&quot;...&quot;&gt;  </span><br><span class="line">&lt;!-- collaborators and configuration for this bean go here --&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;...&quot; class=&quot;...&quot;&gt;</span><br><span class="line">&lt;!-- collaborators and configuration for this bean go here --&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;!-- more bean definitions go here --&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>3、我们可以去进行测试了 .</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test()&#123;</span><br><span class="line">   //解析beans.xml文件 , 生成管理相应的Bean对象</span><br><span class="line">   ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);</span><br><span class="line">   //getBean : 参数即为spring配置文件中bean的id .</span><br><span class="line">   Hello hello = (Hello) context.getBean(&quot;hello&quot;);</span><br><span class="line">   hello.show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>思考</p></blockquote><ul><li>Hello 对象是谁创建的 ?   hello 对象是由Spring创建的</li><li>Hello 对象的属性是怎么设置的 ?  hello 对象的属性是由Spring容器设置的</li></ul><p>这个过程就叫控制反转 :</p><ul><li>控制 : 谁来控制对象的创建 , 传统应用程序的对象是由程序本身控制创建的 , 使用Spring后 , 对象是由Spring来创建的</li><li>反转 : 程序本身不创建对象 , 而变成被动的接收对象 .</li></ul><p>依赖注入 : 就是利用set方法来进行注入的.</p><p> IOC是一种编程思想，由主动的编程变成被动的接收</p><p>可以通过newClassPathXmlApplicationContext去浏览一下底层源码 .</p><blockquote><p>修改案例一</p></blockquote><p>我们在案例一中， 新增一个Spring配置文件beans.xml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">   &lt;bean id=&quot;MysqlImpl&quot; class=&quot;com.kuang.dao.impl.UserDaoMySqlImpl&quot;/&gt;</span><br><span class="line">   &lt;bean id=&quot;OracleImpl&quot; class=&quot;com.kuang.dao.impl.UserDaoOracleImpl&quot;/&gt;</span><br><span class="line"></span><br><span class="line">   &lt;bean id=&quot;ServiceImpl&quot; class=&quot;com.kuang.service.impl.UserServiceImpl&quot;&gt;</span><br><span class="line">       &lt;!--注意: 这里的name并不是属性 , 而是set方法后面的那部分 , 首字母小写--&gt;</span><br><span class="line">       &lt;!--引用另外一个bean , 不是用value 而是用 ref--&gt;</span><br><span class="line">       &lt;property name=&quot;userDao&quot; ref=&quot;OracleImpl&quot;/&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>测试！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test2()&#123;</span><br><span class="line">   ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);</span><br><span class="line">   UserServiceImpl serviceImpl = (UserServiceImpl) context.getBean(&quot;ServiceImpl&quot;);</span><br><span class="line">   serviceImpl.getUser();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK , 到了现在 , 我们彻底不用再程序中去改动了 , 要实现不同的操作 , 只需要在xml配置文件中进行修改 , 所谓的IoC,一句话搞定 : 对象由Spring 来创建 , 管理 , 装配 ! </p><h3 id="8-IOC创建对象方式"><a href="#8-IOC创建对象方式" class="headerlink" title="8.IOC创建对象方式"></a><strong>8.IOC创建对象方式</strong></h3><blockquote><p>&#x3D;&#x3D;<strong>通过无参构造方法来创建</strong>&#x3D;&#x3D;</p></blockquote><p>1、User.java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line"></span><br><span class="line">   private String name;</span><br><span class="line"></span><br><span class="line">   public User() &#123;</span><br><span class="line">       System.out.println(&quot;user无参构造方法&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   public void setName(String name) &#123;</span><br><span class="line">       this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   public void show()&#123;</span><br><span class="line">       System.out.println(&quot;name=&quot;+ name );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、beans.xml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">   &lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot;&gt;</span><br><span class="line">       &lt;property name=&quot;name&quot; value=&quot;kuangshen&quot;/&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>3、测试类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test()&#123;</span><br><span class="line">   ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);</span><br><span class="line">   //在执行getBean的时候, user已经创建好了 , 通过无参构造</span><br><span class="line">   User user = (User) context.getBean(&quot;user&quot;);</span><br><span class="line">   //调用对象的方法 .</span><br><span class="line">   user.show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果可以发现，在调用show方法之前，User对象已经通过无参构造初始化了！</p><blockquote><p>&#x3D;&#x3D;<strong>通过有参构造方法来创建</strong>&#x3D;&#x3D;</p></blockquote><p>1、UserT . java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class UserT &#123;</span><br><span class="line"></span><br><span class="line">   private String name;</span><br><span class="line"></span><br><span class="line">   public UserT(String name) &#123;</span><br><span class="line">       this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   public void setName(String name) &#123;</span><br><span class="line">       this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   public void show()&#123;</span><br><span class="line">       System.out.println(&quot;name=&quot;+ name );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、beans.xml 有三种方式编写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 第一种根据index参数下标设置 --&gt;</span><br><span class="line">&lt;bean id=&quot;userT&quot; class=&quot;com.kuang.pojo.UserT&quot;&gt;</span><br><span class="line">   &lt;!-- index指构造方法 , 下标从0开始 --&gt;</span><br><span class="line">   &lt;constructor-arg index=&quot;0&quot; value=&quot;kuangshen2&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;!-- 第二种根据参数名字设置 --&gt;</span><br><span class="line">&lt;bean id=&quot;userT&quot; class=&quot;com.kuang.pojo.UserT&quot;&gt;</span><br><span class="line">   &lt;!-- name指参数名 --&gt;</span><br><span class="line">   &lt;constructor-arg name=&quot;name&quot; value=&quot;kuangshen2&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;!-- 第三种根据参数类型设置（不建议使用） --&gt;</span><br><span class="line">&lt;bean id=&quot;userT&quot; class=&quot;com.kuang.pojo.UserT&quot;&gt;</span><br><span class="line">   &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;kuangshen2&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>3、测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testT()&#123;</span><br><span class="line">   ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);</span><br><span class="line">   UserT user = (UserT) context.getBean(&quot;userT&quot;);</span><br><span class="line">   user.show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结论：在配置文件加载的时候。其中管理的对象都已经初始化了！</p><h3 id="9-Spring配置"><a href="#9-Spring配置" class="headerlink" title="9.Spring配置"></a><strong>9.Spring配置</strong></h3><blockquote><p>别名</p></blockquote><p>alias 设置别名 , 为bean设置别名 , 可以设置多个别名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--设置别名：在获取Bean的时候可以使用别名获取--&gt;</span><br><span class="line">&lt;alias name=&quot;userT&quot; alias=&quot;userNew&quot;/&gt;</span><br></pre></td></tr></table></figure><blockquote><p>Bean的配置</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--bean就是java对象,由Spring创建和管理--&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--</span><br><span class="line">   id 是bean的标识符,要唯一,如果没有配置id,name就是默认标识符（相当于我们学的对象名）</span><br><span class="line">   如果配置id,又配置了name,那么name是别名</span><br><span class="line">   name可以设置多个别名,可以用逗号,分号,空格隔开</span><br><span class="line">   如果不配置id和name,可以根据applicationContext.getBean(.class)获取对象;</span><br><span class="line"></span><br><span class="line">class是bean的全限定名=包名+类名</span><br><span class="line">--&gt;</span><br><span class="line">&lt;bean id=&quot;hello&quot; name=&quot;hello2 h2,h3;h4&quot; class=&quot;com.kuang.pojo.Hello&quot;&gt;</span><br><span class="line">   &lt;property name=&quot;name&quot; value=&quot;Spring&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><blockquote><p>import</p></blockquote><p>团队的合作通过import来实现 ，可以将多个配置文件，导入合并为一个。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;import resource=&quot;&#123;path&#125;/beans.xml&quot;/&gt;</span><br></pre></td></tr></table></figure><p>假设，现在项目中有多个人开发，这三个人负责不同的类开发，不同的类的需要注册在不同的bean中，我们可以利用import将所有人的beans.xml合并为一个总的。</p><ul><li>张三</li><li>李四</li><li>王五</li><li>applicationContext.xml</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;import resource=&quot;beans.xml&quot;/&gt;</span><br><span class="line">&lt;import resource=&quot;beans2.xml&quot;/&gt;</span><br><span class="line">&lt;import resource=&quot;beans3.xml&quot;/&gt;</span><br></pre></td></tr></table></figure><p>使用的时候使用总的就可</p><h3 id="10-依赖注入"><a href="#10-依赖注入" class="headerlink" title="10.依赖注入"></a><strong>10.依赖注入</strong></h3><blockquote><p>&#x3D;&#x3D;概念&#x3D;&#x3D;</p></blockquote><ul><li>依赖注入（Dependency Injection,DI）。</li><li>依赖 : 指Bean对象的创建依赖于容器 . Bean对象的依赖资源 .</li><li>注入 : 指Bean对象所依赖的资源 , 由容器来设置和装配 .</li></ul><blockquote><p>&#x3D;&#x3D;构造器注入&#x3D;&#x3D;</p></blockquote><p>我们在之前的案例已经讲过了</p><blockquote><p>&#x3D;&#x3D;Set 注入 （重点）&#x3D;&#x3D;</p></blockquote><p>要求被注入的属性 , 必须有set方法 , set方法的方法名由set + 属性首字母大写 , 如果属性是boolean类型 , 没有set方法 , 是 is .</p><p>测试pojo类 :</p><p>Address.java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Address &#123;</span><br><span class="line"></span><br><span class="line">    private String address;</span><br><span class="line"></span><br><span class="line">    public String getAddress() &#123;</span><br><span class="line">        return address;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    public void setAddress(String address) &#123;</span><br><span class="line">        this.address = address;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Student.java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">package com.kuang.pojo;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.Properties;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">public class Student &#123;</span><br><span class="line"></span><br><span class="line">   private String name;</span><br><span class="line">   private Address address;</span><br><span class="line">   private String[] books;</span><br><span class="line">   private List&lt;String&gt; hobbys;</span><br><span class="line">   private Map&lt;String,String&gt; card;</span><br><span class="line">   private Set&lt;String&gt; games;</span><br><span class="line">   private String wife;</span><br><span class="line">   private Properties info;</span><br><span class="line"></span><br><span class="line">   public String getName() &#123;</span><br><span class="line">       return name;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public void setName(String name) &#123;</span><br><span class="line">       this.name = name;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public Address getAddress() &#123;</span><br><span class="line">       return address;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public void setAddress(Address address) &#123;</span><br><span class="line">       this.address = address;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public String[] getBooks() &#123;</span><br><span class="line">       return books;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public void setBooks(String[] books) &#123;</span><br><span class="line">       this.books = books;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public List&lt;String&gt; getHobbys() &#123;</span><br><span class="line">       return hobbys;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public void setHobbys(List&lt;String&gt; hobbys) &#123;</span><br><span class="line">       this.hobbys = hobbys;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public Map&lt;String, String&gt; getCard() &#123;</span><br><span class="line">       return card;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public void setCard(Map&lt;String, String&gt; card) &#123;</span><br><span class="line">       this.card = card;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public Set&lt;String&gt; getGames() &#123;</span><br><span class="line">       return games;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public void setGames(Set&lt;String&gt; games) &#123;</span><br><span class="line">       this.games = games;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public String getWife() &#123;</span><br><span class="line">       return wife;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public void setWife(String wife) &#123;</span><br><span class="line">       this.wife = wife;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public Properties getInfo() &#123;</span><br><span class="line">       return info;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public void setInfo(Properties info) &#123;</span><br><span class="line">       this.info = info;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public String toString() &#123;</span><br><span class="line">       return &quot;Hello&#123;&quot; +</span><br><span class="line">               &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">               &quot;, address=&quot; + address +</span><br><span class="line">               &quot;, books=&quot; + Arrays.toString(books) +</span><br><span class="line">               &quot;, hobbys=&quot; + hobbys +</span><br><span class="line">               &quot;, card=&quot; + card +</span><br><span class="line">               &quot;, games=&quot; + games +</span><br><span class="line">               &quot;, wife=&#x27;&quot; + wife + &#x27;\&#x27;&#x27; +</span><br><span class="line">               &quot;, info=&quot; + info +</span><br><span class="line">               &#x27;&#125;&#x27;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、常量注入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;student&quot; class=&quot;com.kuang.pojo.Student&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;name&quot; value=&quot;小明&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test01()&#123;</span><br><span class="line">    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line"></span><br><span class="line">    Student student = (Student) context.getBean(&quot;student&quot;);</span><br><span class="line"></span><br><span class="line">    System.out.println(student.toString());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、Bean注入 </p><p>注意点：这里的值是一个引用，ref</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;addr&quot; class=&quot;com.kuang.pojo.Address&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;address&quot; value=&quot;重庆&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;student&quot; class=&quot;com.kuang.pojo.Student&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;name&quot; value=&quot;小明&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;address&quot; ref=&quot;addr&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>3、数组注入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;student&quot; class=&quot;com.kuang.pojo.Student&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;name&quot; value=&quot;小明&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;address&quot; ref=&quot;addr&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;books&quot;&gt;</span><br><span class="line">        &lt;array&gt;</span><br><span class="line">            &lt;value&gt;西游记&lt;/value&gt;</span><br><span class="line">            &lt;value&gt;红楼梦&lt;/value&gt;</span><br><span class="line">            &lt;value&gt;水浒传&lt;/value&gt;</span><br><span class="line">        &lt;/array&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>4、List注入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;property name=&quot;hobbys&quot;&gt;</span><br><span class="line">    &lt;list&gt;</span><br><span class="line">        &lt;value&gt;听歌&lt;/value&gt;</span><br><span class="line">        &lt;value&gt;看电影&lt;/value&gt;</span><br><span class="line">        &lt;value&gt;爬山&lt;/value&gt;</span><br><span class="line">    &lt;/list&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure><p>5、Map注入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;property name=&quot;card&quot;&gt;</span><br><span class="line">    &lt;map&gt;</span><br><span class="line">        &lt;entry key=&quot;中国邮政&quot; value=&quot;456456456465456&quot;/&gt;</span><br><span class="line">        &lt;entry key=&quot;建设&quot; value=&quot;1456682255511&quot;/&gt;</span><br><span class="line">    &lt;/map&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure><p>6、set注入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;property name=&quot;games&quot;&gt;</span><br><span class="line">    &lt;set&gt;</span><br><span class="line">        &lt;value&gt;LOL&lt;/value&gt;</span><br><span class="line">        &lt;value&gt;BOB&lt;/value&gt;</span><br><span class="line">        &lt;value&gt;COC&lt;/value&gt;</span><br><span class="line">    &lt;/set&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure><p>7、Null注入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;property name=&quot;wife&quot;&gt;&lt;null/&gt;&lt;/property&gt;</span><br></pre></td></tr></table></figure><p>8、Properties注入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;property name=&quot;info&quot;&gt;</span><br><span class="line">    &lt;props&gt;</span><br><span class="line">        &lt;prop key=&quot;学号&quot;&gt;20190604&lt;/prop&gt;</span><br><span class="line">        &lt;prop key=&quot;性别&quot;&gt;男&lt;/prop&gt;</span><br><span class="line">        &lt;prop key=&quot;姓名&quot;&gt;小明&lt;/prop&gt;</span><br><span class="line">    &lt;/props&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure><p>测试结果：</p><p><img src="/../UpPictures/SpringPictures/image-20240321163606499.png" alt="image-20240321163606499"></p><blockquote><p>&#x3D;&#x3D;p命名和c命名注入&#x3D;&#x3D;(拓展方式)</p></blockquote><p>User.java ：【注意：这里没有有参构造器！】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;User&#123;&quot; +</span><br><span class="line">                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, age=&quot; + age +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、P命名空间注入 : 需要在头文件中加入约束文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">导入约束 : xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</span><br><span class="line"></span><br><span class="line">&lt;!--P(属性: properties)命名空间 , 属性依然要设置set方法--&gt;</span><br><span class="line">&lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot; p:name=&quot;狂神&quot; p:age=&quot;18&quot;/&gt;</span><br></pre></td></tr></table></figure><p>2、c 命名空间注入 : 需要在头文件中加入约束文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">导入约束 : xmlns:c=&quot;http://www.springframework.org/schema/c&quot;</span><br><span class="line">&lt;!--C(构造: Constructor)命名空间 , 属性依然要设置set方法--&gt;</span><br><span class="line">&lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot; c:name=&quot;狂神&quot; c:age=&quot;18&quot;/&gt;</span><br></pre></td></tr></table></figure><p>发现问题：爆红了，刚才我们没有写有参构造！</p><p>解决：&#x3D;&#x3D;把有参构造器加上，这里也能知道，c 就是所谓的构造器注入！&#x3D;&#x3D;</p><p>测试代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test02()&#123;</span><br><span class="line">    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">    User user = (User) context.getBean(&quot;user&quot;);//等价于User user = context.getBean(&quot;user&quot;,User.class);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>&#x3D;&#x3D;Bean的作用域&#x3D;&#x3D;</p></blockquote><p>在Spring中，那些组成应用程序的主体及由Spring IoC容器所管理的对象，被称之为bean。简单地讲，bean就是由IoC容器初始化、装配及管理的对象 .</p><p><img src="/../UpPictures/SpringPictures/image-20240321163628280.png" alt="image-20240321163628280"></p><p>几种作用域中，request、session作用域仅在基于web的应用中使用（不必关心你所采用的是什么web应用框架），只能用在基于web的Spring ApplicationContext环境。</p><p><strong>Singleton</strong>（Spring默认机制）</p><p>当一个bean的作用域为Singleton，那么Spring IoC容器中只会存在一个共享的bean实例，并且所有对bean的请求，只要id与该bean定义相匹配，则只会返回bean的同一实例。Singleton是单例类型，就是在创建起容器时就同时自动创建了一个bean的对象，不管你是否使用，他都存在了，每次获取到的对象都是同一个对象。注意，Singleton作用域是Spring中的缺省作用域。要在XML中将bean定义成singleton，可以这样配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;ServiceImpl&quot; class=&quot;cn.csdn.service.ServiceImpl&quot; scope=&quot;singleton&quot;&gt;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test03()&#123;</span><br><span class="line">    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">    User user = (User) context.getBean(&quot;user&quot;);</span><br><span class="line">    User user2 = (User) context.getBean(&quot;user&quot;);</span><br><span class="line">    System.out.println(user==user2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Prototype</strong></p><p>当一个bean的作用域为Prototype，表示一个bean定义对应多个对象实例。Prototype作用域的bean会导致在每次对该bean请求（将其注入到另一个bean中，或者以程序的方式调用容器的getBean()方法）时都会创建一个新的bean实例。Prototype是原型类型，它在我们创建容器的时候并没有实例化，而是当我们获取bean的时候才会去创建一个对象，而且我们每次获取到的对象都不是同一个对象。根据经验，对有状态的bean应该使用prototype作用域，而对无状态的bean则应该使用singleton作用域。在XML中将bean定义成prototype，可以这样配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;account&quot; class=&quot;com.foo.DefaultAccount&quot; scope=&quot;prototype&quot;/&gt;  </span><br><span class="line"> 或者</span><br><span class="line">&lt;bean id=&quot;account&quot; class=&quot;com.foo.DefaultAccount&quot; singleton=&quot;false&quot;/&gt;</span><br></pre></td></tr></table></figure><p><strong>Request</strong></p><p>当一个bean的作用域为Request，表示在一次HTTP请求中，一个bean定义对应一个实例；即每个HTTP请求都会有各自的bean实例，它们依据某个bean定义创建而成。该作用域仅在基于web的Spring ApplicationContext情形下有效。考虑下面bean定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;loginAction&quot; class=cn.csdn.LoginAction&quot; scope=&quot;request&quot;/&gt;</span><br></pre></td></tr></table></figure><p>针对每次HTTP请求，Spring容器会根据loginAction bean的定义创建一个全新的LoginAction bean实例，且该loginAction bean实例仅在当前HTTP request内有效，因此可以根据需要放心的更改所建实例的内部状态，而其他请求中根据loginAction bean定义创建的实例，将不会看到这些特定于某个请求的状态变化。当处理请求结束，request作用域的bean实例将被销毁。</p><p><strong>Session</strong></p><p>当一个bean的作用域为Session，表示在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。考虑下面bean定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;userPreferences&quot; class=&quot;com.foo.UserPreferences&quot; scope=&quot;session&quot;/&gt;</span><br></pre></td></tr></table></figure><p>针对某个HTTP Session，Spring容器会根据userPreferences bean定义创建一个全新的userPreferences bean实例，且该userPreferences bean仅在当前HTTP Session内有效。与request作用域一样，可以根据需要放心的更改所创建实例的内部状态，而别的HTTP Session中根据userPreferences创建的实例，将不会看到这些特定于某个HTTP Session的状态变化。当HTTP Session最终被废弃的时候，在该HTTP Session作用域内的bean也会被废弃掉。</p><h3 id="11-Bean的自动装配"><a href="#11-Bean的自动装配" class="headerlink" title="11.Bean的自动装配"></a>11.Bean的自动装配</h3><blockquote><p>&#x3D;&#x3D;自动装配说明&#x3D;&#x3D;</p></blockquote><ul><li>自动装配是使用spring满足bean依赖的一种方法</li><li>spring会在上下文中自动寻找，并自动给bean装备属性</li></ul><p>Spring中bean有三种装配机制，分别是：</p><ol><li><strong>在xml中显式配置；</strong></li><li><strong>在java中显式配置；</strong></li><li><strong>隐式的bean发现机制和自动装配。</strong>【重要】</li></ol><p>这里我们主要讲第三种：自动化的装配bean。</p><p>Spring的自动装配需要从两个角度来实现，或者说是两个操作：</p><ol><li>组件扫描(component scanning)：spring会自动发现应用上下文中所创建的bean；</li><li>自动装配(autowiring)：spring自动满足bean之间的依赖，也就是我们说的IoC&#x2F;DI；</li></ol><p>组件扫描和自动装配组合发挥巨大威力，使得显示的配置降低到最少。</p><p><strong>推荐不使用自动装配xml配置 , 而使用注解 .</strong></p><blockquote><p>&#x3D;&#x3D;测试环境搭建&#x3D;&#x3D;</p></blockquote><p>1、新建一个项目</p><p>2、新建两个实体类，Cat  Dog  都有一个叫的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Cat &#123;</span><br><span class="line">   public void shout() &#123;</span><br><span class="line">       System.out.println(&quot;miao~&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Dog &#123;</span><br><span class="line">   public void shout() &#123;</span><br><span class="line">       System.out.println(&quot;wang~&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、新建一个用户类 User</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">    private Cat cat;</span><br><span class="line">    private Dog dog;</span><br><span class="line">    private String str;</span><br><span class="line"></span><br><span class="line">    public Cat getCat() &#123;</span><br><span class="line">        return cat;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCat(Cat cat) &#123;</span><br><span class="line">        this.cat = cat;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Dog getDog() &#123;</span><br><span class="line">        return dog;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setDog(Dog dog) &#123;</span><br><span class="line">        this.dog = dog;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getStr() &#123;</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setStr(String str) &#123;</span><br><span class="line">        this.str = str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Hello&#123;&quot; +</span><br><span class="line">                &quot;cat=&quot; + cat +</span><br><span class="line">                &quot;, dog=&quot; + dog +</span><br><span class="line">                &quot;, str=&#x27;&quot; + str + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、编写Spring配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">   &lt;bean id=&quot;dog&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;</span><br><span class="line">   &lt;bean id=&quot;cat&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;</span><br><span class="line"></span><br><span class="line">   &lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot;&gt;</span><br><span class="line">       &lt;property name=&quot;cat&quot; ref=&quot;cat&quot;/&gt;</span><br><span class="line">       &lt;property name=&quot;dog&quot; ref=&quot;dog&quot;/&gt;</span><br><span class="line">       &lt;property name=&quot;str&quot; value=&quot;qinjiang&quot;/&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>5、测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class MyTest &#123;</span><br><span class="line">   @Test</span><br><span class="line">   public void testMethodAutowire() &#123;</span><br><span class="line">       ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);</span><br><span class="line">       User user = (User) context.getBean(&quot;user&quot;);</span><br><span class="line">       user.getCat().shout();</span><br><span class="line">       user.getDog().shout();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果正常输出，环境OK</p><blockquote><p>&#x3D;&#x3D;byName&#x3D;&#x3D;</p></blockquote><p><strong>autowire byName (按名称自动装配)</strong></p><p>由于在手动配置xml过程中，常常发生字母缺漏和大小写等错误，而无法对其进行检查，使得开发效率降低。</p><p>采用自动装配将避免这些错误，并且使配置简单化。</p><p>测试：</p><p>1、修改bean配置，增加一个属性  autowire&#x3D;”byName”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">   &lt;bean id=&quot;dog&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;</span><br><span class="line">   &lt;!--会自动在容器上下文中查找(也就是上面)，和自己对象set方法后面的值对应的bean id--&gt;</span><br><span class="line">&lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot; autowire=&quot;byName&quot;&gt;</span><br><span class="line">   &lt;property name=&quot;str&quot; value=&quot;qinjiang&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>2、再次测试，结果依旧成功输出！</p><p>3、我们将 cat 的bean id修改为 catXXX</p><p>4、再次测试， 执行时报空指针java.lang.NullPointerException。因为按byName规则找不对应set方法，真正的setCat就没执行，对象就没有初始化，所以调用时就会报空指针错误。</p><p><strong>小结：</strong></p><p>当一个bean节点带有 autowire byName的属性时。</p><ol><li><p>将查找其类中所有的set方法名，例如setCat，获得将set去掉并且首字母小写的字符串，即cat。</p></li><li><p>去spring容器中寻找是否有此字符串名称id的对象。</p></li><li><p>如果有，就取出注入；如果没有，就报空指针异常。</p></li></ol><blockquote><p>&#x3D;&#x3D;byType&#x3D;&#x3D;</p></blockquote><p><strong>autowire byType (按类型自动装配)</strong></p><p>使用autowire byType首先需要保证：同一类型的对象，在spring容器中唯一。如果不唯一，会报不唯一的异常。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NoUniqueBeanDefinitionException</span><br></pre></td></tr></table></figure><p>测试：</p><p>1、将user的bean配置修改一下 ： autowire&#x3D;”byType”</p><p>2、测试，正常输出</p><p>3、在注册一个cat 的bean对象！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;dog&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;</span><br><span class="line">&lt;bean id=&quot;cat&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;</span><br><span class="line">&lt;bean id=&quot;cat2&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;</span><br><span class="line"> &lt;!--会自动在容器上下文中查找(也就是上面)，和自己对象属性类型相同的bean--&gt;</span><br><span class="line">&lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot; autowire=&quot;byType&quot;&gt;</span><br><span class="line">   &lt;property name=&quot;str&quot; value=&quot;qinjiang&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>4、测试，报错：NoUniqueBeanDefinitionException</p><p>5、删掉cat2，将cat的bean名称改掉！测试！因为是按类型装配，所以并不会报异常，也不影响最后的结果。甚至将id属性去掉，也不影响结果。</p><p><strong>小结：</strong></p><p>byname的时候，需要保证所有bean的id唯一，并且这个bean需要和自动注入的属性的set方法的值一致。</p><p>bytype的时候，需要保证所有bean的class唯一，并且这个bean需要和自动注入的属性的类型一样。</p><p>这就是按照类型自动装配！</p><blockquote><p>&#x3D;&#x3D;使用注解&#x3D;&#x3D;</p></blockquote><p>jdk1.5开始支持注解，spring2.5开始全面支持注解。</p><p>准备工作：利用注解的方式注入属性。</p><p>1、在spring配置文件中引入context文件头</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line"></span><br><span class="line">http://www.springframework.org/schema/context</span><br><span class="line">http://www.springframework.org/schema/context/spring-context.xsd</span><br></pre></td></tr></table></figure><p>2、开启属性注解支持！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:annotation-config/&gt;</span><br></pre></td></tr></table></figure><p><strong>@Autowired</strong>(有点小问题)</p><ul><li>直接在属性上使用即可，也可以在set方式上使用</li><li>使用Autowired我们可以不用编写Set方法了，前提是你这个自动装配的属性在IOC（Spring）容器中存在</li><li>@Autowired是按类型自动装配的，不支持id匹配。</li></ul><p>测试：</p><p>1、将User类中的set方法去掉，使用@Autowired注解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">   @Autowired</span><br><span class="line">   private Cat cat;</span><br><span class="line">   @Autowired</span><br><span class="line">   private Dog dog;</span><br><span class="line">   private String str;</span><br><span class="line"></span><br><span class="line">   public Cat getCat() &#123;</span><br><span class="line">       return cat;</span><br><span class="line">  &#125;</span><br><span class="line">   public Dog getDog() &#123;</span><br><span class="line">       return dog;</span><br><span class="line">  &#125;</span><br><span class="line">   public String getStr() &#123;</span><br><span class="line">       return str;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、此时配置文件内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:annotation-config/&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;dog&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;</span><br><span class="line">&lt;bean id=&quot;cat&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;</span><br><span class="line">&lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot;/&gt;</span><br></pre></td></tr></table></figure><p>3、测试，成功输出结果！</p><p>4.科普</p><p>@Autowired(required&#x3D;false)  说明：false，对象可以为null；true，对象必须存对象，不能为null。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//如果允许对象为null，设置required = false,默认为true</span><br><span class="line">@Autowired(required = false)</span><br><span class="line">private Cat cat;</span><br></pre></td></tr></table></figure><p><strong>@Qualifier</strong></p><ul><li>如果@Autowired自动装配的环境比较复杂，自动装配无法通过一个注解【@Autowired】完成的时候，我们可以使用@Qualifier(value&#x3D;”xxx”)去配置@Autowired的使用，指定一个唯一的bean对象注入。</li><li>@Autowired是根据类型自动装配的，加上@Qualifier则可以根据byName的方式自动装配</li><li><strong>@Qualifier不能单独使用</strong>。</li></ul><p>测试实验步骤：</p><p>1、配置文件修改内容，保证类型存在对象。且名字不为类的默认名字！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;dog1&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;</span><br><span class="line">&lt;bean id=&quot;dog2&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;</span><br><span class="line">&lt;bean id=&quot;cat1&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;</span><br><span class="line">&lt;bean id=&quot;cat2&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;</span><br></pre></td></tr></table></figure><p>2、没有加Qualifier测试，直接报错</p><p>3、在属性上添加Qualifier注解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">@Qualifier(value = &quot;cat2&quot;)</span><br><span class="line">private Cat cat;</span><br><span class="line">@Autowired</span><br><span class="line">@Qualifier(value = &quot;dog2&quot;)</span><br><span class="line">private Dog dog;</span><br></pre></td></tr></table></figure><p>测试，成功输出！</p><p><strong>@Nullable</strong></p><p>字段标记了这个注解，说明这个字段可以为null</p><p><strong>@Resource</strong></p><ul><li>@Resource如有指定的name属性，先按该属性进行byName方式查找装配；</li><li>其次再进行默认的byName方式进行装配；</li><li>如果以上都不成功，则按byType的方式自动装配。</li><li>都不成功，则报异常。</li></ul><p>实体类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">   //如果允许对象为null，设置required = false,默认为true</span><br><span class="line">   @Resource(name = &quot;cat2&quot;)</span><br><span class="line">   private Cat cat;</span><br><span class="line">   @Resource</span><br><span class="line">   private Dog dog;</span><br><span class="line">   private String str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>beans.xml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;dog&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;</span><br><span class="line">&lt;bean id=&quot;cat1&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;</span><br><span class="line">&lt;bean id=&quot;cat2&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot;/&gt;</span><br></pre></td></tr></table></figure><p>测试：结果OK</p><p>配置文件2：beans.xml ， 删掉cat2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;dog&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;</span><br><span class="line">&lt;bean id=&quot;cat1&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;</span><br></pre></td></tr></table></figure><p>实体类上只保留注解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Resource</span><br><span class="line">private Cat cat;</span><br><span class="line">@Resource</span><br><span class="line">private Dog dog;</span><br></pre></td></tr></table></figure><p>结果：OK</p><p>结论：先进行byName查找，失败；再进行byType查找，成功。</p><p>&#x3D;&#x3D;小结&#x3D;&#x3D;</p><p>@Autowired与@Resource异同：</p><p>1、@Autowired与@Resource都可以用来装配bean。都可以写在字段上，或写在setter方法上。</p><p>2、@Autowired默认按类型装配（属于spring规范），默认情况下必须要求依赖对象必须存在，如果要允许null 值，可以设置它的required属性为false，如：@Autowired(required&#x3D;false) ，如果我们想使用名称装配可以结合@Qualifier注解进行使用</p><p>3、@Resource（属于J2EE复返），默认按照名称进行装配，名称可以通过name属性进行指定。如果没有指定name属性，当注解写在字段上时，默认取字段名进行按照名称查找，如果注解写在setter方法上默认取属性名进行装配。当找不到与名称匹配的bean时才按照类型进行装配。但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。</p><p>它们的作用相同都是用注解方式注入对象，但执行顺序不同。@Autowired先byType，@Resource先byName。</p><h3 id="12-使用注解开发"><a href="#12-使用注解开发" class="headerlink" title="12.使用注解开发"></a><strong>12.使用注解开发</strong></h3><blockquote><p>&#x3D;&#x3D;说明&#x3D;&#x3D;</p></blockquote><p>在spring4之后，想要使用注解形式，必须得要引入aop的包</p><p><img src="/../UpPictures/SpringPictures/image-20240321163657252.png" alt="image-20240321163657252"></p><p>在配置文件当中，还得要引入一个context约束</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">      xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">       http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">       http://www.springframework.org/schema/context</span><br><span class="line">       http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><blockquote><p>&#x3D;&#x3D;Bean的实现&#x3D;&#x3D;</p></blockquote><p>我们之前都是使用 bean 的标签进行bean注入，但是实际开发中，我们一般都会使用注解！</p><p>1、配置扫描哪些包下的注解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--指定注解扫描包--&gt;</span><br><span class="line">&lt;context:component-scan base-package=&quot;com.kuang.pojo&quot;/&gt;</span><br></pre></td></tr></table></figure><p>2、在指定包下编写类，增加注解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Component(&quot;user&quot;)</span><br><span class="line">// 相当于配置文件中 &lt;bean id=&quot;user&quot; class=&quot;当前注解的类&quot;/&gt;</span><br><span class="line">public class User &#123;</span><br><span class="line">   public String name = &quot;秦疆&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test()&#123;</span><br><span class="line">   ApplicationContext applicationContext =</span><br><span class="line">       new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);</span><br><span class="line">   User user = (User) applicationContext.getBean(&quot;user&quot;);</span><br><span class="line">   System.out.println(user.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>&#x3D;&#x3D;属性注入&#x3D;&#x3D;</p></blockquote><p>使用注解注入属性</p><p>1、可以不用提供set方法，直接在直接名上添加@value(“值”)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Component(&quot;user&quot;)</span><br><span class="line">// 相当于配置文件中 &lt;bean id=&quot;user&quot; class=&quot;当前注解的类&quot;/&gt;</span><br><span class="line">public class User &#123;</span><br><span class="line">   @Value(&quot;秦疆&quot;)</span><br><span class="line">   // 相当于配置文件中 &lt;property name=&quot;name&quot; value=&quot;秦疆&quot;/&gt;</span><br><span class="line">   public String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、如果提供了set方法，在set方法上添加@value(“值”);</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Component(&quot;user&quot;)</span><br><span class="line">public class User &#123;</span><br><span class="line"></span><br><span class="line">   public String name;</span><br><span class="line"></span><br><span class="line">   @Value(&quot;秦疆&quot;)</span><br><span class="line">   public void setName(String name) &#123;</span><br><span class="line">       this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>&#x3D;&#x3D;衍生注解&#x3D;&#x3D;</p></blockquote><p>我们这些注解，就是替代了在配置文件当中配置步骤而已！更加的方便快捷！</p><p><strong>@Component三个衍生注解</strong></p><p>为了更好的进行分层，Spring可以使用其它三个注解，功能一样，目前使用哪一个功能都一样。</p><ul><li>@Controller：web层</li><li>@Service：service层</li><li>@Repository：dao层</li></ul><p>写上这些注解，就相当于将这个类交给Spring管理装配了！</p><blockquote><p>&#x3D;&#x3D;自动装配注解&#x3D;&#x3D;</p></blockquote><p>在Bean的自动装配已经讲过了，可以回顾！</p><blockquote><p>&#x3D;&#x3D;作用域&#x3D;&#x3D;</p></blockquote><p>@scope</p><ul><li>singleton：默认的，Spring会采用单例模式创建这个对象。关闭工厂 ，所有的对象都会销毁。</li><li>prototype：多例模式。关闭工厂 ，所有的对象不会销毁。内部的垃圾回收机制会回收</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Controller(&quot;user&quot;)</span><br><span class="line">@Scope(&quot;prototype&quot;)</span><br><span class="line">public class User &#123;</span><br><span class="line">   @Value(&quot;秦疆&quot;)</span><br><span class="line">   public String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>&#x3D;&#x3D;小结&#x3D;&#x3D;</p></blockquote><p><strong>XML与注解比较</strong></p><ul><li>XML可以适用任何场景 ，结构清晰，维护方便</li><li>注解不是自己提供的类使用不了，开发简单方便</li></ul><p><strong>xml与注解整合开发</strong> ：推荐最佳实践</p><ul><li>xml管理Bean</li><li>注解完成属性注入</li><li>使用过程中， 可以不用扫描，扫描是为了类上的注解</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:annotation-config/&gt;  </span><br></pre></td></tr></table></figure><p>作用：</p><ul><li><p>进行注解驱动注册，从而使注解生效</p></li><li><p>用于激活那些已经在spring容器里注册过的bean上面的注解，也就是显示的向Spring注册</p></li><li><p>如果不扫描包，就需要手动配置bean</p></li><li><p>如果不加注解驱动，则注入的值为null！</p></li></ul><blockquote><p>&#x3D;&#x3D;基于Java类进行配置&#x3D;&#x3D;</p></blockquote><p>JavaConfig 原来是 Spring 的一个子项目，它通过 Java 类的方式提供 Bean 的定义信息，在 Spring4 的版本， JavaConfig 已正式成为 Spring4 的核心功能 。</p><p>测试：</p><p>1、编写一个实体类，Dog</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Component  //将这个类标注为Spring的一个组件，放到容器中！</span><br><span class="line">public class Dog &#123;</span><br><span class="line">   public String name = &quot;dog&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、新建一个config配置包，编写一个MyConfig配置类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Configuration  //代表这是一个配置类</span><br><span class="line">public class MyConfig &#123;</span><br><span class="line"></span><br><span class="line">   @Bean //通过方法注册一个bean，这里的返回值就Bean的类型，方法名就是bean的id！</span><br><span class="line">   public Dog dog()&#123;</span><br><span class="line">       return new Dog();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test2()&#123;</span><br><span class="line">   ApplicationContext applicationContext =</span><br><span class="line">           new AnnotationConfigApplicationContext(MyConfig.class);</span><br><span class="line">   Dog dog = (Dog) applicationContext.getBean(&quot;dog&quot;);</span><br><span class="line">   System.out.println(dog.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、成功输出结果！</p><p><strong>导入其他配置如何做呢？</strong></p><p>1、我们再编写一个配置类！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Configuration  //代表这是一个配置类</span><br><span class="line">public class MyConfig2 &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、在之前的配置类中我们来选择导入这个配置类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@Import(MyConfig2.class)  //导入合并其他配置类，类似于配置文件中的 inculde 标签</span><br><span class="line">public class MyConfig &#123;</span><br><span class="line"></span><br><span class="line">   @Bean</span><br><span class="line">   public Dog dog()&#123;</span><br><span class="line">       return new Dog();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于这种Java类的配置方式，我们在之后的SpringBoot 和 SpringCloud中还会大量看到，我们需要知道这些注解的作用即可！</p><h3 id="13-代理模式"><a href="#13-代理模式" class="headerlink" title="13.代理模式"></a><strong>13.代理模式</strong></h3><p>为什么要学习代理模式，因为AOP的底层机制就是动态代理！</p><p>代理模式：</p><ul><li>静态代理</li><li>动态代理</li></ul><p>学习aop之前 , 我们要先了解一下代理模式！</p><p><img src="/../UpPictures/SpringPictures/image-20240321163716926.png" alt="image-20240321163716926"></p><blockquote><p>&#x3D;&#x3D;静态代理&#x3D;&#x3D;</p></blockquote><p><strong>静态代理角色分析</strong></p><ul><li><p>抽象角色 : 一般使用接口或者抽象类来实现</p></li><li><p>真实角色 : 被代理的角色</p></li><li><p>代理角色 : 代理真实角色 ; 代理真实角色后 , 一般会做一些附属的操作 .</p></li><li><p>客户  :  使用代理角色来进行一些操作 .</p></li></ul><p><strong>代码实现</strong></p><p>Rent . java 即抽象角色</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//抽象角色：租房</span><br><span class="line">public interface Rent &#123;</span><br><span class="line">   public void rent();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Host . java 即真实角色</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//真实角色: 房东，房东要出租房子</span><br><span class="line">public class Host implements Rent&#123;</span><br><span class="line">   public void rent() &#123;</span><br><span class="line">       System.out.println(&quot;房屋出租&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Proxy . java 即代理角色</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//代理角色：中介</span><br><span class="line">public class Proxy implements Rent &#123;</span><br><span class="line"></span><br><span class="line">   private Host host;</span><br><span class="line">   public Proxy() &#123; &#125;</span><br><span class="line">   public Proxy(Host host) &#123;</span><br><span class="line">       this.host = host;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   //租房</span><br><span class="line">   public void rent()&#123;</span><br><span class="line">       seeHouse();</span><br><span class="line">       host.rent();</span><br><span class="line">       fare();</span><br><span class="line">  &#125;</span><br><span class="line">   //看房</span><br><span class="line">   public void seeHouse()&#123;</span><br><span class="line">       System.out.println(&quot;带房客看房&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">   //收中介费</span><br><span class="line">   public void fare()&#123;</span><br><span class="line">       System.out.println(&quot;收中介费&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Client . java 即客户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户类，一般客户都会去找代理！</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="comment">//房东要租房</span></span><br><span class="line">       <span class="type">Host</span> <span class="variable">host</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Host</span>();</span><br><span class="line">       <span class="comment">//代理，中介帮助房东</span></span><br><span class="line">       <span class="type">Proxy</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(host);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//你不用面对房东，直接找中介租房即可</span></span><br><span class="line">       proxy.rent();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析：在这个过程中，你直接接触的就是中介，就如同现实生活中的样子，你看不到房东，但是你依旧租到了房东的房子通过代理，这就是所谓的代理模式，程序源自于生活，所以学编程的人，一般能够更加抽象的看待生活中发生的事情。</p><p><strong>静态代理的好处:</strong></p><ul><li>可以使得我们的真实角色更加纯粹 . 不再去关注一些公共的事情 .</li><li>公共的业务由代理来完成 . 实现了业务的分工 ,</li><li>公共业务发生扩展时变得更加集中和方便 .</li></ul><p>缺点 :</p><ul><li><p>一个真实角色就会产生一个代理角色；代码率会翻倍。</p></li><li><p>类多了 , 多了代理类 , 工作量变大了 . 开发效率降低 .</p></li></ul><p>我们想要静态代理的好处，又不想要静态代理的缺点，所以 , 就有了动态代理 !</p><blockquote><p>&#x3D;&#x3D;静态代理再理解&#x3D;&#x3D;</p></blockquote><p>同学们练习完毕后，我们再来举一个例子，巩固大家的学习！</p><p>练习步骤：</p><p>1、创建一个抽象角色，比如咋们平时做的用户业务，抽象起来就是增删改查！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//抽象角色：增删改查业务</span><br><span class="line">public interface UserService &#123;</span><br><span class="line">   void add();</span><br><span class="line">   void delete();</span><br><span class="line">   void update();</span><br><span class="line">   void query();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、我们需要一个真实对象来完成这些增删改查操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//真实对象，完成增删改查操作的人</span><br><span class="line">public class UserServiceImpl implements UserService &#123;</span><br><span class="line"></span><br><span class="line">   public void add() &#123;</span><br><span class="line">       System.out.println(&quot;增加了一个用户&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   public void delete() &#123;</span><br><span class="line">       System.out.println(&quot;删除了一个用户&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   public void update() &#123;</span><br><span class="line">       System.out.println(&quot;更新了一个用户&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   public void query() &#123;</span><br><span class="line">       System.out.println(&quot;查询了一个用户&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、需求来了，现在我们需要增加一个日志功能，怎么实现！</p><ul><li>思路1 ：在实现类上增加代码 【麻烦！】</li><li>思路2：使用代理来做，能够不改变原来的业务情况下，实现此功能就是最好的了！</li></ul><p>4、设置一个代理类来处理日志！代理角色</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//代理角色，在这里面增加日志的实现</span><br><span class="line">public class UserServiceProxy implements UserService &#123;</span><br><span class="line">   private UserServiceImpl userService;</span><br><span class="line"></span><br><span class="line">   public void setUserService(UserServiceImpl userService) &#123;</span><br><span class="line">       this.userService = userService;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   public void add() &#123;</span><br><span class="line">       log(&quot;add&quot;);</span><br><span class="line">       userService.add();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   public void delete() &#123;</span><br><span class="line">       log(&quot;delete&quot;);</span><br><span class="line">       userService.delete();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   public void update() &#123;</span><br><span class="line">       log(&quot;update&quot;);</span><br><span class="line">       userService.update();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   public void query() &#123;</span><br><span class="line">       log(&quot;query&quot;);</span><br><span class="line">       userService.query();</span><br><span class="line">  &#125;</span><br><span class="line">   //日志方法</span><br><span class="line">   public void log(String msg)&#123;</span><br><span class="line">       System.out.println(&quot;执行了&quot;+msg+&quot;方法&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、测试访问类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">       //真实业务</span><br><span class="line">       UserServiceImpl userService = new UserServiceImpl();</span><br><span class="line">       //代理类</span><br><span class="line">       UserServiceProxy proxy = new UserServiceProxy();</span><br><span class="line">       //使用代理类实现日志功能！</span><br><span class="line">       proxy.setUserService(userService);</span><br><span class="line"></span><br><span class="line">       proxy.add();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK，到了现在代理模式大家应该都没有什么问题了，重点大家需要理解其中的思想；</p><p>我们在不改变原来的代码的情况下，实现了对原有功能的增强，这是AOP中最核心的思想</p><p>聊聊AOP：纵向开发，横向开发</p><p><img src="/../UpPictures/SpringPictures/image-20240321163738766.png" alt="image-20240321163738766"></p><blockquote><p> &#x3D;&#x3D;动态代理&#x3D;&#x3D;</p></blockquote><ul><li><p>动态代理的角色和静态代理的一样 .</p></li><li><p><strong>动态代理</strong>的代理类是<strong>动态生成的</strong> . 静态代理的代理类是我们提前写好的</p></li><li><p>动态代理分为两类 : 一类是基于接口动态代理 , 一类是基于类的动态代理</p><ul><li>基于接口的动态代理—-JDK动态代理【我们这里使用JDK的原生代码来实现，其余的道理都是一样的！】</li><li>基于类的动态代理–cglib</li><li>现在用的比较多的是 javasist 来生成动态代理 . 百度一下javasist</li></ul></li></ul><p><strong>JDK的动态代理需要了解两个类</strong></p><p>核心 : InvocationHandler   和   Proxy  ， 打开JDK帮助文档看看【<a href="https://www.runoob.com/manual/jdk11api/%E3%80%91">https://www.runoob.com/manual/jdk11api/】</a></p><p>【InvocationHandler：调用处理程序】</p><p><img src="/../UpPictures/SpringPictures/image-20240321163757577.png" alt="image-20240321163757577"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object invoke(Object proxy, 方法 method, Object[] args)；</span><br><span class="line">//参数</span><br><span class="line">//proxy - 调用该方法的代理实例</span><br><span class="line">//method -所述方法对应于调用代理实例上的接口方法的实例。方法对象的声明类将是该方法声明的接口，它可以是代理类继承该方法的代理接口的超级接口。</span><br><span class="line">//args -包含的方法调用传递代理实例的参数值的对象的阵列，或null如果接口方法没有参数。原始类型的参数包含在适当的原始包装器类的实例中，例如java.lang.Integer或java.lang.Boolean 。</span><br></pre></td></tr></table></figure><p>【Proxy  : 代理】</p><p><img src="/../UpPictures/SpringPictures/image-20240321163811252.png" alt="图片"></p><p><img src="/../UpPictures/SpringPictures/image-20240321163826384.png" alt="image-20240321163826384"></p><p><img src="/../UpPictures/SpringPictures/image-20240321163840242.png" alt="image-20240321163840242"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//生成代理类</span><br><span class="line">public Object getProxy()&#123;</span><br><span class="line">   return Proxy.newProxyInstance(this.getClass().getClassLoader(),</span><br><span class="line">                                 rent.getClass().getInterfaces(),this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码实现</strong> </p><p>抽象角色和真实角色和之前的一样！</p><p>Rent . java 即抽象角色</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//抽象角色：租房</span><br><span class="line">public interface Rent &#123;</span><br><span class="line">   public void rent();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Host . java 即真实角色</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//真实角色: 房东，房东要出租房子</span><br><span class="line">public class Host implements Rent&#123;</span><br><span class="line">   public void rent() &#123;</span><br><span class="line">       System.out.println(&quot;房屋出租&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ProxyInvocationHandler. java 即代理角色</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">//等会我们用这个类，自动生成代理类</span><br><span class="line">public class ProxyInvocationHandler implements InvocationHandler &#123;</span><br><span class="line">   private Rent rent;</span><br><span class="line"></span><br><span class="line">   //被代理的接口</span><br><span class="line">   public void setRent(Rent rent) &#123;</span><br><span class="line">       this.rent = rent;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   //生成代理类，重点是第二个参数，获取要代理的抽象角色！之前都是一个角色，现在可以代理一类角色</span><br><span class="line">   public Object getProxy()&#123;</span><br><span class="line">       return Proxy.newProxyInstance(this.getClass().getClassLoader(),</span><br><span class="line">               rent.getClass().getInterfaces(),this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   // proxy : 代理类 method : 代理类的调用处理程序的方法对象.</span><br><span class="line">   // 处理代理实例上的方法调用并返回结果</span><br><span class="line">   @Override</span><br><span class="line">   public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">       seeHouse();</span><br><span class="line">       //动态代理核心：本质利用反射实现！</span><br><span class="line">       Object result = method.invoke(rent, args);</span><br><span class="line">       fare();</span><br><span class="line">       return result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   //看房</span><br><span class="line">   public void seeHouse()&#123;</span><br><span class="line">       System.out.println(&quot;带房客看房&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">   //收中介费</span><br><span class="line">   public void fare()&#123;</span><br><span class="line">       System.out.println(&quot;收中介费&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Client . java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//租客</span><br><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">       //真实角色</span><br><span class="line">       Host host = new Host();</span><br><span class="line">       //代理实例的调用处理程序</span><br><span class="line">       ProxyInvocationHandler pih = new ProxyInvocationHandler();</span><br><span class="line">       //通过调用程序处理角色来处理我们要调用的接口对象</span><br><span class="line">       pih.setRent(host); //将真实角色放置进去！</span><br><span class="line">       Rent proxy = (Rent)pih.getProxy(); //动态生成对应的代理类！我们并没有写</span><br><span class="line">       proxy.rent();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心：<strong>一个动态代理 , 一般代理某一类业务 , 一个动态代理可以代理多个类，代理的是接口！、</strong></p><blockquote><p>&#x3D;&#x3D;深化理解&#x3D;&#x3D;</p></blockquote><p>我们来使用动态代理实现代理我们后面写的UserService！</p><p>我们也可以编写一个通用的动态代理实现的类！所有的代理对象设置为Object即可！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//等会我们会调用这个类，自动生成代理类</span><br><span class="line">public class ProxyInvocationHandler implements InvocationHandler &#123;</span><br><span class="line">  //被代理的接口</span><br><span class="line">  private Object target;</span><br><span class="line"></span><br><span class="line">   public void setTarget(Object target) &#123;</span><br><span class="line">       this.target = target;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   //生成得到代理类</span><br><span class="line">   public Object getProxy()&#123;</span><br><span class="line">       return Proxy.newProxyInstance(this.getClass().getClassLoader(),</span><br><span class="line">               target.getClass().getInterfaces(),this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   //处理代理实例，并返回结果</span><br><span class="line">   // proxy : 代理类</span><br><span class="line">   // method : 代理类的调用处理程序的方法对象.</span><br><span class="line">   public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">       log(method.getName());</span><br><span class="line">       Object result = method.invoke(target, args);</span><br><span class="line">       return result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   public void log(String methodName)&#123;</span><br><span class="line">       System.out.println(&quot;执行了&quot;+methodName+&quot;方法&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">       //真实对象</span><br><span class="line">       UserServiceImpl userService = new UserServiceImpl();</span><br><span class="line">       //代理角色，不存在，代理对象的调用处理程序</span><br><span class="line">       ProxyInvocationHandler pih = new ProxyInvocationHandler();</span><br><span class="line">       pih.setTarget(userService); //设置要代理的对象</span><br><span class="line">       UserService proxy = (UserService)pih.getProxy(); //动态生成代理类！</span><br><span class="line">       proxy.delete();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试，增删改查，查看结果！</p><blockquote><h5 id="动态代理的好处"><a href="#动态代理的好处" class="headerlink" title="&#x3D;&#x3D;动态代理的好处&#x3D;&#x3D;"></a>&#x3D;&#x3D;动态代理的好处&#x3D;&#x3D;</h5></blockquote><p>静态代理有的它都有，静态代理没有的，它也有！</p><ul><li><p>可以使得我们的真实角色更加纯粹 . 不再去关注一些公共的事情 .</p></li><li><p>公共的业务由代理来完成 . 实现了业务的分工 ,</p></li><li><p>公共业务发生扩展时变得更加集中和方便 .</p></li><li><p>一个动态代理类代理的是一个接口 , 一般就是对应的一类业务</p></li><li><p>一个动态代理类可以代理多个类，只要是实现了同一个接口</p></li></ul><h3 id="14-AOP"><a href="#14-AOP" class="headerlink" title="14.AOP"></a><strong>14.AOP</strong></h3><p>上一讲中我们讲解了代理模式，这是AOP的基础，一定要先搞懂它</p><p>那我们接下来就来聊聊AOP吧！</p><blockquote><p>什么是AOP</p></blockquote><p>AOP（Aspect Oriented Programming）意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p><p><img src="/../UpPictures/SpringPictures/image-20240321163901984.png" alt="image-20240321163901984"></p><blockquote><p>Aop在Spring中的作用</p></blockquote><p>提供声明式事务；允许用户自定义切面</p><p>以下名词需要了解下：</p><ul><li>横切关注点：跨越应用程序多个模块的方法或功能。即是，与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点。如日志 , 安全 , 缓存 , 事务等等 ….</li><li>切面（ASPECT）：横切关注点 被模块化 的特殊对象。即，它是一个类。</li><li>通知（Advice）：切面必须要完成的工作。即，它是类中的一个方法。</li><li>目标（Target）：被通知对象。</li><li>代理（Proxy）：向目标对象应用通知之后创建的对象。</li><li>切入点（PointCut）：切面通知 执行的 “地点”的定义。</li><li>连接点（JointPoint）：与切入点匹配的执行点。</li></ul><p><img src="/../UpPictures/SpringPictures/image-20240321163917256.png" alt="image-20240321163917256"></p><p>SpringAOP中，通过Advice定义横切逻辑，Spring中支持5种类型的Advice:</p><p><img src="/../UpPictures/SpringPictures/image-20240321163929402.png" alt="image-20240321163929402"></p><p>即 Aop 在 不改变原有代码的情况下 , 去增加新的功能 .</p><blockquote><p>使用Spring实现Aop</p></blockquote><p>【重点】使用AOP织入，需要导入一个依赖包！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.aspectj&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;1.9.4&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;<strong>第一种方式</strong>&#x3D;&#x3D;</p><p><strong>通过 Spring API 实现</strong></p><p>首先编写我们的业务接口和实现类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public interface UserService &#123;</span><br><span class="line"></span><br><span class="line">   public void add();</span><br><span class="line"></span><br><span class="line">   public void delete();</span><br><span class="line"></span><br><span class="line">   public void update();</span><br><span class="line"></span><br><span class="line">   public void search();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class UserServiceImpl implements UserService&#123;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void add() &#123;</span><br><span class="line">       System.out.println(&quot;增加用户&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void delete() &#123;</span><br><span class="line">       System.out.println(&quot;删除用户&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void update() &#123;</span><br><span class="line">       System.out.println(&quot;更新用户&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void search() &#123;</span><br><span class="line">       System.out.println(&quot;查询用户&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后去写我们的增强类 , 我们编写两个 , 一个前置增强 一个后置增强</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Log implements MethodBeforeAdvice &#123;</span><br><span class="line"></span><br><span class="line">   //method : 要执行的目标对象的方法</span><br><span class="line">   //objects : 被调用的方法的参数</span><br><span class="line">   //Object : 目标对象</span><br><span class="line">   @Override</span><br><span class="line">   public void before(Method method, Object[] objects, Object o) throws Throwable &#123;</span><br><span class="line">       System.out.println( o.getClass().getName() + &quot;的&quot; + method.getName() + &quot;方法被执行了&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class AfterLog implements AfterReturningAdvice &#123;</span><br><span class="line">   //returnValue 返回值</span><br><span class="line">   //method被调用的方法</span><br><span class="line">   //args 被调用的方法的对象的参数</span><br><span class="line">   //target 被调用的目标对象</span><br><span class="line">   @Override</span><br><span class="line">   public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable &#123;</span><br><span class="line">       System.out.println(&quot;执行了&quot; + target.getClass().getName()</span><br><span class="line">       +&quot;的&quot;+method.getName()+&quot;方法,&quot;</span><br><span class="line">       +&quot;返回值：&quot;+returnValue);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后去spring的文件中注册 , 并实现aop切入实现 , 注意导入约束 .</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">      xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class="line">      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">       http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">       http://www.springframework.org/schema/aop</span><br><span class="line">       http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!--注册bean--&gt;</span><br><span class="line">   &lt;bean id=&quot;userService&quot; class=&quot;com.kuang.service.UserServiceImpl&quot;/&gt;</span><br><span class="line">   &lt;bean id=&quot;log&quot; class=&quot;com.kuang.log.Log&quot;/&gt;</span><br><span class="line">   &lt;bean id=&quot;afterLog&quot; class=&quot;com.kuang.log.AfterLog&quot;/&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!--aop的配置--&gt;</span><br><span class="line">   &lt;aop:config&gt;</span><br><span class="line">       &lt;!--切入点 expression:表达式匹配要执行的方法，execution(要执行的位置* * * * *)--&gt;</span><br><span class="line">       &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;/&gt;</span><br><span class="line">       &lt;!--执行环绕; advice-ref执行方法 . pointcut-ref切入点--&gt;</span><br><span class="line">       &lt;aop:advisor advice-ref=&quot;log&quot; pointcut-ref=&quot;pointcut&quot;/&gt;</span><br><span class="line">       &lt;aop:advisor advice-ref=&quot;afterLog&quot; pointcut-ref=&quot;pointcut&quot;/&gt;</span><br><span class="line">   &lt;/aop:config&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class MyTest &#123;</span><br><span class="line">   @Test</span><br><span class="line">   public void test()&#123;</span><br><span class="line">       ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);</span><br><span class="line">       //动态代理代理的是接口：注意点</span><br><span class="line">       UserService userService = (UserService) context.getBean(&quot;userService&quot;);</span><br><span class="line">       userService.search();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Aop的重要性 : 很重要 . 一定要理解其中的思路 , 主要是思想的理解这一块 .</p><p>Spring的Aop就是将公共的业务 (日志 , 安全等) 和领域业务结合起来 , 当执行领域业务时 , 将会把公共业务加进来 . 实现公共业务的重复利用 . 领域业务更纯粹 , 程序猿专注领域业务 , 其本质还是动态代理 . </p><p>&#x3D;&#x3D;<strong>第二种方式</strong>&#x3D;&#x3D;</p><p><strong>自定义类来实现Aop</strong></p><p>目标业务类不变依旧是userServiceImpl</p><p>第一步 : 写我们自己的一个切入类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class DiyPointcut &#123;</span><br><span class="line"></span><br><span class="line">   public void before()&#123;</span><br><span class="line">       System.out.println(&quot;---------方法执行前---------&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">   public void after()&#123;</span><br><span class="line">       System.out.println(&quot;---------方法执行后---------&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>去spring中配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--第二种方式自定义实现--&gt;</span><br><span class="line">&lt;!--注册bean--&gt;</span><br><span class="line">&lt;bean id=&quot;diy&quot; class=&quot;com.kuang.config.DiyPointcut&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--aop的配置--&gt;</span><br><span class="line">&lt;aop:config&gt;</span><br><span class="line">   &lt;!--第二种方式：使用AOP的标签实现，ref要引用的类--&gt;</span><br><span class="line">   &lt;aop:aspect ref=&quot;diy&quot;&gt;</span><br><span class="line">       &lt;aop:pointcut id=&quot;diyPonitcut&quot; expression=&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;/&gt;</span><br><span class="line">       &lt;aop:before pointcut-ref=&quot;diyPonitcut&quot; method=&quot;before&quot;/&gt;</span><br><span class="line">       &lt;aop:after pointcut-ref=&quot;diyPonitcut&quot; method=&quot;after&quot;/&gt;</span><br><span class="line">   &lt;/aop:aspect&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class MyTest &#123;</span><br><span class="line">   @Test</span><br><span class="line">   public void test()&#123;</span><br><span class="line">       ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);</span><br><span class="line">       UserService userService = (UserService) context.getBean(&quot;userService&quot;);</span><br><span class="line">       userService.add();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;<strong>第三种方式</strong>&#x3D;&#x3D;</p><p><strong>使用注解实现</strong></p><p>第一步：编写一个注解实现的增强类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package com.kuang.config;</span><br><span class="line"></span><br><span class="line">import org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line">import org.aspectj.lang.annotation.After;</span><br><span class="line">import org.aspectj.lang.annotation.Around;</span><br><span class="line">import org.aspectj.lang.annotation.Aspect;</span><br><span class="line">import org.aspectj.lang.annotation.Before;</span><br><span class="line"></span><br><span class="line">@Aspect//标注这个类是一个切面</span><br><span class="line">public class AnnotationPointcut &#123;</span><br><span class="line">   @Before(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;)</span><br><span class="line">   public void before()&#123;</span><br><span class="line">       System.out.println(&quot;---------方法执行前---------&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   @After(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;)</span><br><span class="line">   public void after()&#123;</span><br><span class="line">       System.out.println(&quot;---------方法执行后---------&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   //在环绕增增强中，我们可以给定一个参数，代表我们要获取处理切入的点</span><br><span class="line">   @Around(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;)</span><br><span class="line">   public void around(ProceedingJoinPoint jp) throws Throwable &#123;</span><br><span class="line">       System.out.println(&quot;环绕前&quot;);</span><br><span class="line">       System.out.println(&quot;签名:&quot;+jp.getSignature());</span><br><span class="line">       //执行目标方法proceed</span><br><span class="line">       Object proceed = jp.proceed();</span><br><span class="line">       System.out.println(&quot;环绕后&quot;);</span><br><span class="line">       System.out.println(proceed);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步：在Spring配置文件中，注册bean，并增加支持注解的配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--第三种方式:注解实现--&gt;</span><br><span class="line">&lt;bean id=&quot;annotationPointcut&quot; class=&quot;com.kuang.config.AnnotationPointcut&quot;/&gt;</span><br><span class="line">&lt;!--开启注解支持--&gt;</span><br><span class="line">&lt;aop:aspectj-autoproxy/&gt;</span><br></pre></td></tr></table></figure><p>aop:aspectj-autoproxy：说明</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">通过aop命名空间的&lt;aop:aspectj-autoproxy /&gt;声明自动为spring容器中那些配置@aspectJ切面的bean创建代理，织入切面。当然，spring 在内部依旧采用AnnotationAwareAspectJAutoProxyCreator进行自动代理的创建工作，但具体实现的细节已经被&lt;aop:aspectj-autoproxy /&gt;隐藏起来了</span><br><span class="line"></span><br><span class="line">&lt;aop:aspectj-autoproxy /&gt;有一个proxy-target-class属性，默认为false，表示使用jdk动态代理织入增强，当配为&lt;aop:aspectj-autoproxy  poxy-target-class=&quot;true&quot;/&gt;时，表示使用CGLib动态代理技术织入增强。不过即使proxy-target-class设置为false，如果目标类没有声明接口，则spring将自动使用CGLib动态代理。</span><br></pre></td></tr></table></figure><h3 id="15-整合MyBatis"><a href="#15-整合MyBatis" class="headerlink" title="15.整合MyBatis"></a><strong>15.整合MyBatis</strong></h3><blockquote><p>&#x3D;&#x3D;步骤&#x3D;&#x3D;</p></blockquote><p>1、导入相关jar包</p><p>junit</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;4.12&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>mybatis</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;3.5.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>mysql-connector-java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;5.1.47&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>spring相关：Spring操作数据库的话需要</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;5.1.10.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;5.1.10.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>aspectJ AOP 织入器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.aspectj&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;1.9.4&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>mybatis-spring整合包 【重点】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;2.0.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>配置Maven静态资源过滤问题！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">   &lt;resources&gt;</span><br><span class="line">       &lt;resource&gt;</span><br><span class="line">           &lt;directory&gt;src/main/java&lt;/directory&gt;</span><br><span class="line">           &lt;includes&gt;</span><br><span class="line">               &lt;include&gt;**/*.properties&lt;/include&gt;</span><br><span class="line">               &lt;include&gt;**/*.xml&lt;/include&gt;</span><br><span class="line">           &lt;/includes&gt;</span><br><span class="line">           &lt;filtering&gt;true&lt;/filtering&gt;</span><br><span class="line">       &lt;/resource&gt;</span><br><span class="line">   &lt;/resources&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure><p>2、编写配置文件</p><p>3、代码实现</p><blockquote><p>&#x3D;&#x3D;回忆MyBatis&#x3D;&#x3D;</p></blockquote><p><strong>编写pojo实体类</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package com.kuang.pojo;</span><br><span class="line"></span><br><span class="line">public class User &#123;</span><br><span class="line">   private int id;  //id</span><br><span class="line">   private String name;   //姓名</span><br><span class="line">   private String pwd;   //密码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实现mybatis的配置文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">       PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span><br><span class="line">       &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line"></span><br><span class="line">   &lt;typeAliases&gt;</span><br><span class="line">       &lt;package name=&quot;com.kuang.pojo&quot;/&gt;</span><br><span class="line">   &lt;/typeAliases&gt;</span><br><span class="line"></span><br><span class="line">   &lt;environments default=&quot;development&quot;&gt;</span><br><span class="line">       &lt;environment id=&quot;development&quot;&gt;</span><br><span class="line">           &lt;transactionManager type=&quot;JDBC&quot;/&gt;</span><br><span class="line">           &lt;dataSource type=&quot;POOLED&quot;&gt;</span><br><span class="line">               &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;</span><br><span class="line">               &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf8&quot;/&gt;</span><br><span class="line">               &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;</span><br><span class="line">               &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;</span><br><span class="line">           &lt;/dataSource&gt;</span><br><span class="line">       &lt;/environment&gt;</span><br><span class="line">   &lt;/environments&gt;</span><br><span class="line"></span><br><span class="line">   &lt;mappers&gt;</span><br><span class="line">       &lt;package name=&quot;com.kuang.dao&quot;/&gt;</span><br><span class="line">   &lt;/mappers&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><p><strong>UserDao接口编写</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface UserMapper &#123;</span><br><span class="line">   public List&lt;User&gt; selectUser();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>接口对应的Mapper映射文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">       PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line">       &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace=&quot;com.kuang.dao.UserMapper&quot;&gt;</span><br><span class="line"></span><br><span class="line">   &lt;select id=&quot;selectUser&quot; resultType=&quot;User&quot;&gt;</span><br><span class="line">    select * from user</span><br><span class="line">   &lt;/select&gt;</span><br><span class="line"></span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure><p><strong>测试类</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void selectUser() throws IOException &#123;</span><br><span class="line"></span><br><span class="line">   String resource = &quot;mybatis-config.xml&quot;;</span><br><span class="line">   InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">   SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">   SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line"></span><br><span class="line">   UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">   List&lt;User&gt; userList = mapper.selectUser();</span><br><span class="line">   for (User user: userList)&#123;</span><br><span class="line">       System.out.println(user);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>&#x3D;&#x3D;MyBatis-Spring学习&#x3D;&#x3D;</p></blockquote><p>引入Spring之前需要了解mybatis-spring包中的一些重要类；</p><p><a href="http://www.mybatis.org/spring/zh/index.html">http://www.mybatis.org/spring/zh/index.html</a></p><p><img src="/../UpPictures/SpringPictures/image-20240321164002010.png" alt="image-20240321164002010"></p><p><strong>什么是 MyBatis-Spring？</strong></p><p>MyBatis-Spring 会帮助你将 MyBatis 代码无缝地整合到 Spring 中。</p><p><strong>知识基础</strong></p><p>在开始使用 MyBatis-Spring 之前，你需要先熟悉 Spring 和 MyBatis 这两个框架和有关它们的术语。这很重要</p><p>MyBatis-Spring 需要以下版本：</p><table><thead><tr><th align="left">MyBatis-Spring</th><th align="left">MyBatis</th><th align="left">Spring 框架</th><th align="left">Spring Batch</th><th align="left">Java</th></tr></thead><tbody><tr><td align="left">2.0</td><td align="left">3.5+</td><td align="left">5.0+</td><td align="left">4.0+</td><td align="left">Java 8+</td></tr><tr><td align="left">1.3</td><td align="left">3.4+</td><td align="left">3.2.2+</td><td align="left">2.1+</td><td align="left">Java 6+</td></tr></tbody></table><p>如果使用 Maven 作为构建工具，仅需要在 pom.xml 中加入以下代码即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;2.0.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>要和 Spring 一起使用 MyBatis，需要在 Spring 应用上下文中定义至少两样东西：一个 SqlSessionFactory 和至少一个数据映射器类。</p><p>在 MyBatis-Spring 中，可使用SqlSessionFactoryBean来创建 SqlSessionFactory。要配置这个工厂 bean，只需要把下面代码放在 Spring 的 XML 配置文件中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;</span><br><span class="line"> &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>注意：SqlSessionFactory需要一个 DataSource（数据源）。这可以是任意的 DataSource，只需要和配置其它 Spring 数据库连接一样配置它就可以了。</p><p>在基础的 MyBatis 用法中，是通过 SqlSessionFactoryBuilder 来创建 SqlSessionFactory 的。而在 MyBatis-Spring 中，则使用 SqlSessionFactoryBean 来创建。</p><p>在 MyBatis 中，你可以使用 SqlSessionFactory 来创建 SqlSession。一旦你获得一个 session 之后，你可以使用它来执行映射了的语句，提交或回滚连接，最后，当不再需要它的时候，你可以关闭 session。</p><p>SqlSessionFactory有一个唯一的必要属性：用于 JDBC 的 DataSource。这可以是任意的 DataSource 对象，它的配置方法和其它 Spring 数据库连接是一样的。</p><p>一个常用的属性是 configLocation，它用来指定 MyBatis 的 XML 配置文件路径。它在需要修改 MyBatis 的基础配置非常有用。通常，基础配置指的是 &lt; settings&gt; 或 &lt; typeAliases&gt;元素。</p><p>需要注意的是，这个配置文件并不需要是一个完整的 MyBatis 配置。确切地说，任何环境配置（<environments>），数据源（<DataSource>）和 MyBatis 的事务管理器（<transactionManager>）都会被忽略。SqlSessionFactoryBean 会创建它自有的 MyBatis 环境配置（Environment），并按要求设置自定义环境的值。</p><p>SqlSessionTemplate 是 MyBatis-Spring 的核心。作为 SqlSession 的一个实现，这意味着可以使用它无缝代替你代码中已经在使用的 SqlSession。</p><p>模板可以参与到 Spring 的事务管理中，并且由于其是线程安全的，可以供多个映射器类使用，你应该总是用 SqlSessionTemplate 来替换 MyBatis 默认的 DefaultSqlSession 实现。在同一应用程序中的不同类之间混杂使用可能会引起数据一致性的问题。</p><p>可以使用 SqlSessionFactory 作为构造方法的参数来创建 SqlSessionTemplate 对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;sqlSession&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt;</span><br><span class="line"> &lt;constructor-arg index=&quot;0&quot; ref=&quot;sqlSessionFactory&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>现在，这个 bean 就可以直接注入到你的 DAO bean 中了。你需要在你的 bean 中添加一个 SqlSession 属性，就像下面这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class UserDaoImpl implements UserDao &#123;</span><br><span class="line"></span><br><span class="line"> private SqlSession sqlSession;</span><br><span class="line"></span><br><span class="line"> public void setSqlSession(SqlSession sqlSession) &#123;</span><br><span class="line">   this.sqlSession = sqlSession;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> public User getUser(String userId) &#123;</span><br><span class="line">   return sqlSession.getMapper...;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按下面这样，注入 SqlSessionTemplate：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;userDao&quot; class=&quot;org.mybatis.spring.sample.dao.UserDaoImpl&quot;&gt;</span><br><span class="line"> &lt;property name=&quot;sqlSession&quot; ref=&quot;sqlSession&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><blockquote><p>&#x3D;&#x3D;整合实现一&#x3D;&#x3D;</p></blockquote><p>1、引入Spring配置文件beans.xml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br></pre></td></tr></table></figure><p>2、配置数据源替换mybaits的数据源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--配置数据源：数据源有非常多，可以使用第三方的，也可使使用Spring的</span><br><span class="line">    我们这里使用Spring提供的JDBC：&quot;org.springframework.jdbc.datasource</span><br><span class="line">--&gt;</span><br><span class="line">&lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;</span><br><span class="line">   &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;</span><br><span class="line">   &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf8&quot;/&gt;</span><br><span class="line">   &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;</span><br><span class="line">   &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>3、配置SqlSessionFactory，关联MyBatis</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--配置SqlSessionFactory--&gt;</span><br><span class="line">&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;</span><br><span class="line">   &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;</span><br><span class="line">   &lt;!--关联Mybatis--&gt;</span><br><span class="line">   &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt;</span><br><span class="line">   &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:com/kuang/dao/*.xml&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>4、注册sqlSessionTemplate，关联sqlSessionFactory；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--注册sqlSessionTemplate：就是我们使用的sqlSession , 关联sqlSessionFactory--&gt;</span><br><span class="line">&lt;bean id=&quot;sqlSession&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt;</span><br><span class="line">   &lt;!--利用构造器注入，因为它没有set方法--&gt;</span><br><span class="line">   &lt;constructor-arg index=&quot;0&quot; ref=&quot;sqlSessionFactory&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>5、增加Dao接口的实现类；私有化sqlSessionTemplate</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class UserDaoImpl implements UserMapper &#123;</span><br><span class="line"></span><br><span class="line">   //sqlSession不用我们自己创建了，Spring来管理</span><br><span class="line">   //我们所有的操作，都使用sqlSession来执行，在原来，现在都使用sqlSessionTemplate</span><br><span class="line">   private SqlSessionTemplate sqlSession;</span><br><span class="line"></span><br><span class="line">   public void setSqlSession(SqlSessionTemplate sqlSession) &#123;</span><br><span class="line">       this.sqlSession = sqlSession;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   public List&lt;User&gt; selectUser() &#123;</span><br><span class="line">       UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">       return mapper.selectUser();</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6、注册bean实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;userDao&quot; class=&quot;com.kuang.dao.UserDaoImpl&quot;&gt;</span><br><span class="line">   &lt;property name=&quot;sqlSession&quot; ref=&quot;sqlSession&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>7、测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> @Test</span><br><span class="line"> public void test2()&#123;</span><br><span class="line">     ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);</span><br><span class="line">     UserMapper mapper = (UserMapper) context.getBean(&quot;userDao&quot;);</span><br><span class="line">     List&lt;User&gt; user = mapper.selectUser();</span><br><span class="line">     System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果成功输出！现在我们的Mybatis配置文件的状态！发现都可以被Spring整合！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">       PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span><br><span class="line">       &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">   &lt;typeAliases&gt;</span><br><span class="line">       &lt;package name=&quot;com.kuang.pojo&quot;/&gt;</span><br><span class="line">   &lt;/typeAliases&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><blockquote><p>&#x3D;&#x3D;整合实现二&#x3D;&#x3D;</p></blockquote><p>mybatis-spring1.2.3版以上的才有这个 .</p><p>官方文档截图 :</p><p>dao继承Support类 , 直接利用 getSqlSession() 获得 , 然后直接注入SqlSessionFactory . 比起方式1 , 不需要管理SqlSessionTemplate , 而且对事务的支持更加友好 . 可跟踪源码查看</p><p><img src="/../UpPictures/SpringPictures/image-20240321164020429.png" alt="image-20240321164020429"></p><p>测试：</p><p>1、将我们上面写的UserDaoImpl修改一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class UserDaoImpl extends SqlSessionDaoSupport implements UserMapper &#123;</span><br><span class="line">   public List&lt;User&gt; selectUser() &#123;</span><br><span class="line">       UserMapper mapper = getSqlSession().getMapper(UserMapper.class);</span><br><span class="line">       return mapper.selectUser();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、修改bean的配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;userDao&quot; class=&quot;com.kuang.dao.UserDaoImpl&quot;&gt;</span><br><span class="line">   &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>3、测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test2()&#123;</span><br><span class="line">   ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);</span><br><span class="line">   UserMapper mapper = (UserMapper) context.getBean(&quot;userDao&quot;);</span><br><span class="line">   List&lt;User&gt; user = mapper.selectUser();</span><br><span class="line">   System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结 : 整合到spring以后可以完全不要mybatis的配置文件，除了这些方式可以实现整合之外，我们还可以使用注解来实现，这个等我们后面学习SpringBoot的时候还会测试整合！</strong></p><h3 id="16-声明式事务"><a href="#16-声明式事务" class="headerlink" title="16.声明式事务"></a><strong>16.声明式事务</strong></h3><blockquote><p> &#x3D;&#x3D;回顾事务&#x3D;&#x3D;</p></blockquote><ul><li><p>事务在项目开发过程非常重要，涉及到数据的一致性的问题，不容马虎！</p></li><li><p>事务管理是企业级应用程序开发中必备技术，用来确保数据的完整性和一致性。</p></li><li><p>事务就是把一系列的动作当成一个独立的工作单元，这些动作要么全部完成，要么全部不起作用。</p></li></ul><p><strong>事务四个属性ACID</strong></p><ol><li>原子性（atomicity）</li></ol><ul><li>事务是原子性操作，由一系列动作组成，事务的原子性确保动作要么全部完成，要么完全不起作用</li></ul><ol start="2"><li>一致性（consistency）</li></ol><ul><li>一旦所有事务动作完成，事务就要被提交。数据和资源处于一种满足业务规则的一致性状态中</li></ul><ol start="3"><li>隔离性（isolation）</li></ol><ul><li>可能多个事务会同时处理相同的数据，因此每个事务都应该与其他事务隔离开来，防止数据损坏</li></ul><ol start="4"><li>持久性（durability）</li></ol><ul><li>事务一旦完成，无论系统发生什么错误，结果都不会受到影响。通常情况下，事务的结果被写到持久化存储器中</li></ul><blockquote><p>&#x3D;&#x3D;测试&#x3D;&#x3D;</p></blockquote><p>将上面的代码拷贝到一个新项目中</p><p>在之前的案例中，我们给userDao接口新增两个方法，删除和增加用户；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//添加一个用户</span><br><span class="line">int addUser(User user);</span><br><span class="line"></span><br><span class="line">//根据id删除用户</span><br><span class="line">int deleteUser(int id);</span><br></pre></td></tr></table></figure><p>mapper文件，我们故意把 deletes 写错，测试！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id=&quot;addUser&quot; parameterType=&quot;com.kuang.pojo.User&quot;&gt;</span><br><span class="line">insert into user (id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;)</span><br><span class="line">&lt;/insert&gt;</span><br><span class="line"></span><br><span class="line">&lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt;</span><br><span class="line">deletes from user where id = #&#123;id&#125;</span><br><span class="line">&lt;/delete&gt;</span><br></pre></td></tr></table></figure><p>编写接口的实现类，在实现类中，我们去操作一波</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class UserDaoImpl extends SqlSessionDaoSupport implements UserMapper &#123;</span><br><span class="line"></span><br><span class="line">   //增加一些操作</span><br><span class="line">   public List&lt;User&gt; selectUser() &#123;</span><br><span class="line">       User user = new User(4,&quot;小明&quot;,&quot;123456&quot;);</span><br><span class="line">       UserMapper mapper = getSqlSession().getMapper(UserMapper.class);</span><br><span class="line">       mapper.addUser(user);</span><br><span class="line">       mapper.deleteUser(4);</span><br><span class="line">       return mapper.selectUser();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   //新增</span><br><span class="line">   public int addUser(User user) &#123;</span><br><span class="line">       UserMapper mapper = getSqlSession().getMapper(UserMapper.class);</span><br><span class="line">       return mapper.addUser(user);</span><br><span class="line">  &#125;</span><br><span class="line">   //删除</span><br><span class="line">   public int deleteUser(int id) &#123;</span><br><span class="line">       UserMapper mapper = getSqlSession().getMapper(UserMapper.class);</span><br><span class="line">       return mapper.deleteUser(id);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test2()&#123;</span><br><span class="line">   ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);</span><br><span class="line">   UserMapper mapper = (UserMapper) context.getBean(&quot;userDao&quot;);</span><br><span class="line">   List&lt;User&gt; user = mapper.selectUser();</span><br><span class="line">   System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>报错：sql异常，delete写错了</p><p>结果 ：插入成功！</p><p>没有进行事务的管理；我们想让他们都成功才成功，有一个失败，就都失败，我们就应该需要<strong>事务！</strong></p><p>以前我们都需要自己手动管理事务，十分麻烦！</p><p>但是Spring给我们提供了事务管理，我们只需要配置即可；</p><blockquote><p>&#x3D;&#x3D;Spring中的事务管理&#x3D;&#x3D;</p></blockquote><p>Spring在不同的事务管理API之上定义了一个抽象层，使得开发人员不必了解底层的事务管理API就可以使用Spring的事务管理机制。Spring支持编程式事务管理和声明式的事务管理。</p><p><strong>编程式事务管理</strong></p><ul><li>将事务管理代码嵌到业务方法中来控制事务的提交和回滚</li><li>缺点：必须在每个事务操作业务逻辑中包含额外的事务管理代码</li></ul><p><strong>声明式事务管理</strong></p><ul><li>一般情况下比编程式事务好用。</li><li>将事务管理代码从业务方法中分离出来，以声明的方式来实现事务管理。</li><li>将事务管理作为横切关注点，通过aop方法模块化。Spring中通过Spring AOP框架支持声明式事务管理。</li></ul><p><strong>使用Spring管理事务，注意头文件的约束导入 : tx</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;</span><br><span class="line"></span><br><span class="line">http://www.springframework.org/schema/tx</span><br><span class="line">http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;</span><br></pre></td></tr></table></figure><p><strong>事务管理器</strong></p><ul><li>无论使用Spring的哪种事务管理策略（编程式或者声明式）事务管理器都是必须的。</li><li>就是 Spring的核心事务管理抽象，管理封装了一组独立于技术的方法。</li></ul><p><strong>JDBC事务</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">       &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p><strong>配置好事务管理器后我们需要去配置事务的通知</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--配置事务通知--&gt;</span><br><span class="line">&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;</span><br><span class="line">   &lt;tx:attributes&gt;</span><br><span class="line">       &lt;!--配置哪些方法使用什么样的事务,配置事务的传播特性--&gt;</span><br><span class="line">       &lt;tx:method name=&quot;add&quot; propagation=&quot;REQUIRED&quot;/&gt;</span><br><span class="line">       &lt;tx:method name=&quot;delete&quot; propagation=&quot;REQUIRED&quot;/&gt;</span><br><span class="line">       &lt;tx:method name=&quot;update&quot; propagation=&quot;REQUIRED&quot;/&gt;</span><br><span class="line">       &lt;tx:method name=&quot;search*&quot; propagation=&quot;REQUIRED&quot;/&gt;</span><br><span class="line">       &lt;tx:method name=&quot;get&quot; read-only=&quot;true&quot;/&gt;</span><br><span class="line">       &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt;</span><br><span class="line">   &lt;/tx:attributes&gt;</span><br><span class="line">&lt;/tx:advice&gt;</span><br></pre></td></tr></table></figure><p><strong>spring事务传播特性：</strong></p><p>事务传播行为就是多个事务方法相互调用时，事务如何在这些方法间传播。spring支持7种事务传播行为：</p><ul><li>propagation_requierd：如果当前没有事务，就新建一个事务，如果已存在一个事务中，加入到这个事务中，这是最常见的选择。</li><li>propagation_supports：支持当前事务，如果没有当前事务，就以非事务方法执行。</li><li>propagation_mandatory：使用当前事务，如果没有当前事务，就抛出异常。</li><li>propagation_required_new：新建事务，如果当前存在事务，把当前事务挂起。</li><li>propagation_not_supported：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li><li>propagation_never：以非事务方式执行操作，如果当前事务存在则抛出异常。</li><li>propagation_nested：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与propagation_required类似的操作</li></ul><p>Spring 默认的事务传播行为是 PROPAGATION_REQUIRED，它适合于绝大多数的情况。</p><p>假设 ServiveX#methodX() 都工作在事务环境下（即都被 Spring 事务增强了），假设程序中存在如下的调用链：Service1#method1()-&gt;Service2#method2()-&gt;Service3#method3()，那么这 3 个服务类的 3 个方法通过 Spring 的事务传播机制都工作在同一个事务中。</p><p>就好比，我们刚才的几个方法存在调用，所以会被放在一组事务当中！</p><p><strong>配置AOP</strong></p><p>导入aop的头文件！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--配置aop织入事务--&gt;</span><br><span class="line">&lt;aop:config&gt;</span><br><span class="line">   &lt;aop:pointcut id=&quot;txPointcut&quot; expression=&quot;execution(* com.kuang.dao.*.*(..))&quot;/&gt;</span><br><span class="line">   &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txPointcut&quot;/&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure><p><strong>进行测试</strong></p><p>删掉刚才插入的数据，再次测试！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test2()&#123;</span><br><span class="line">   ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);</span><br><span class="line">   UserMapper mapper = (UserMapper) context.getBean(&quot;userDao&quot;);</span><br><span class="line">   List&lt;User&gt; user = mapper.selectUser();</span><br><span class="line">   System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>&#x3D;&#x3D;思考问题？&#x3D;&#x3D;</p></blockquote><p>为什么需要配置事务？</p><ul><li>如果不配置，就需要我们手动提交控制事务；</li><li>事务在项目开发过程非常重要，涉及到数据的一致性的问题，不容马虎！</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/12/21/hello-world/"/>
      <url>/2023/12/21/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
